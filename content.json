{"meta":{"title":"Beeeenf's blog","subtitle":null,"description":null,"author":"beeeenf","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Auto Layout Guide Translate","slug":"Auto-Layout-Guide-Translate","date":"2018-02-12T07:26:11.000Z","updated":"2018-02-13T06:27:42.886Z","comments":true,"path":"2018/02/12/Auto-Layout-Guide-Translate/","link":"","permalink":"http://yoursite.com/2018/02/12/Auto-Layout-Guide-Translate/","excerpt":"","text":"开始吧理解 Auto Layout​ Auto Layout 做了什么？ 在你的视图层级中，Auto Layout根据他们之间的 constraints ，动态地计算每一个视图的 大小 与 位置 。例如，你可以给一个 button 添加这样的 constraints ， 让它水平方向上与一个Image View 居中对齐，同时让它的顶部边缘与 Image View 的底部边缘之间保持8个 points （水平居中？这个可能翻译有误。。理解 constraints 是干啥的就可）。假如这个 Image View 的大小或者位置发生了改变，这个 button 的 位置 会自动调整来满足那些 constraints 。 ​ 这种基于 constraints 的设计方法，使我们搭建的用户界面，可以动态的响应来自外部、内部的变动。 外部的变动​ 外部的变动是指 父视图 的 大小 、 形状 发生了变动。 ​ 每当发生外部变动的时候，为了最好地利用空间，必须更新视图层级的布局。以下是一些常见的外部变动的触发源： 用户调整了应用程序窗口的大小（OS X）。 在iPad上，用户进入或者离开了 Split View 模式。 设备旋转（iOS）。 正在呼叫中的电话栏、录音中的录音栏的出现或者消失（iOS）。 你想支持不同的 size classes。 你想支持不同的屏幕尺寸。 这些触发源中，大部分都会在 运行时 发生。当它们发生时，需要我们的App动态的进行响应。另外的那小部分，比如支持不同的屏幕尺寸，那代表我们的App适用于不同的设备环境。尽管屏幕尺寸在运行时不会发生改变，但是创建一个自动适应的界面，可以让我们的App在 iPhone 4s、iPhone 6s Plus、甚至iPad上，都能良好的运行。Auto Layout 也是 iPad 支持 Slide Over 、 Split Views 的关键部分。 内部的变动​ 内部的变动是指，我们界面中的 视图 、 控件 的大小发生了变动。以下是一些常见的内部变动的触发源： App呈现的内容发生了变动。 App支持了国际化。 App支持了动态字体（iOS）。 当你App的内容发生了变动，新的内容或许需要一个不一样的布局。这些常常发生在，那些需要展示文本、图片的App中。例如，一个新闻类的App需要基于单个新闻文章的大小来调整自己的布局。类似地，一个拼接图片的App须处理好大量图片的大小和长宽比。 国际化 是使的你的App能够适用不同语言、地区、文化的这样一个处理过程。一个国际化的App的布局，必须把这些不同全部考虑进去，针对所有该App所支持的所有语言和地区，都要正确的显示呈现。国际化对布局的影响主要体现在三个方面。 当你把你的用户界面翻译成另外一种语言的时候， label 控件会需要不同大小空间，比如，德语一贯比英语需要较多的空间，日语相对需要较少。 不同的地区，就算语言不变，日期和数字的格式也会有不同的情况。这些不同相对于语言的不同来说，比较细微。但是，界面仍然需要去适应 尺寸大小 上的细小变化。 语言的改变不只是影响文本的大小，也会影响布局的组织形式。不同的语言使用不同的布局方向。例如，英语采用从左到右的布局方向，阿拉伯语、希伯来语采用从右到左的布局方向。一般情况下，界面上元素的顺序应该跟布局的大方向保持一致。如果一个 button 在一个视图的右下角（英语环境下），那么在阿拉伯语环境下，它应该在视图的左下角。 最后，如果你的App支持了动态字体，用户便可以改变你App中字体的大小。用户的这一举动，会导致界面上的所有文本元素的宽、高都发生变化。如果用户在App运行的过程中改变了字体的大小，字体和布局都须要调整适应。 Auto Layout VS 基于frame的布局方式布局用户界面有三种主要的方法。你可以通过 编程布局 用户界面，或者使用 autoresizing masks 针对一些外部的变动来自动响应，或者使用 Auto Layout 。 传统的方法是，App为视图层级中的每一个视图设置 frame ，通过这种方式来布局。 frame 定义了一个视图在 父视图 的 坐标系统 中的原点、高、宽。 为了布局你的用户界面，你不得不计算视图层级中每一个视图的大小和位置。如果某个部分发生了变动，你不得不对涉及的所有视图的frame进行重新计算。 从很多方面来说，frame编程布局的方式都是最灵活、最有力的。因为，当发生一个变动时，不夸张的说，你可以做任何你想做的变动。然而，因为你必须得自己管理所有的变动，这样的话，布局一个简单的界面就需要相当大的设计、调试、维护成本。这样的话，创建一个真正的自适应用户界面会使难度增加一个数量级。 你可以使用 autoresizing masks 来帮助减轻这些负担。 autoresizing masks 定义了在一个视图，在它的父视图的 frame 发生变化后，自身的 frame 该如何变化。根据前面说的，父视图的变化属于外部的变动，所以 autoresizing masks 使得 适应外部变动的新布局的产生 变得简单。 然而 autoresizing masks 仅支持能做到的布局的一个相对小的子集。对于复杂的用户界面，你一般需要随着你的编码变动增加 autoresizing masks ，另外，autoresizing masks 仅仅适用于外部的变动，不支持内部的变动。 autoresizing masks 是编码布局的迭代改进，而 Auto Layout是一个全新的方式。我们不再需要考虑视图的 frame ，而是考虑他们之间的关系。 Auto Layout 通过一系列的 constraints 定义你的用户界面。 constraints 代表两个视图之间的一种关系。Auto Layout 基于这些视图之间的约束来计算他们的大小和位置。这样的布局，能够动态的响应来自内部、外部的变动。 通过设置一些约束来产生特定的行为，这个逻辑与面向对象编程大大不同。幸运的是，掌握 Auto Layout跟掌握别的编程技巧区别不大。有两个步骤，首先你需要理解这种基于约束的布局的底层逻辑，然后你需要学习相关的API。学习别的编程技巧时，你能成功地完成这两步，相信 Auto Layout 也一样。 本 guide 的余下部分是为了帮助顺利地你过渡到 Auto Layout。1.2 没有约束的Auto Layout 篇描述了高层次的抽象，这些高层次的抽象简化了支持用户界面的自动布局的创建。1.3 解剖“一个约束” 篇提供了所需的背景理论知识，有了这些，我们才能成功地与 Auto Layout 打交道。1.4 在Interface Builder中使用约束 介绍了设计 Auto Layout 的工具，4.1 编程的方式创建约束 和 2 Auto Layout 食谱 详细介绍了相关的API。最后， 2 Auto Layout 食谱 呈现了不同复杂程度的布局示例，你可以在自己的工程中学习和使用。3 调试 Auto Layout 提供了出问题后的建议和需要使用的工具。 没有约束的Auto Layout​ Stack views 提供了一种简单的方式来利用自动布局的强大功能，而不引入约束的复杂性。单个栈视图定义了用户界面元素的一行或者一列，根据自身的属性，栈视图对这些元素进行排列。自身属性如下： axis（UIStackView iOS）定义了栈视图的方向，要么垂直，要么水平。 orientation（NSStackView Mac OS）定义了栈视图的方向，要么垂直，要么水平。 distribution 定义了沿轴的视图的布局。 alignment 定义了垂直轴的视图的布局。 spacing 定义了两个相邻视图之间的空间。 怎么使用栈视图？在Interface Builder中，拖拽一个水平/垂直的栈视图到我们的画布上，然后拖拽一些内容进去。 如果一个对象有固有的 content size ，在栈视图中，他就以那个大小呈现。如果没有固有的 content size ，Interface Builder 就会给它一个默认的大小。你可以调整这个对象的大小，Interface Builder会添加约束来维持它的大小。 为了进一步调整布局，您可以使用属性检查器修改堆栈视图的属性。例如，下面的例子使用了一个8点的间距和一个填充相等的分布。 栈视图的布局也基于排列视图的 content-hugging 和 compression-resistance 属性 。您可以使用尺寸检查器来修改这些。 NOTE 你可以通过直接给排列视图添加约束，进一步来修改布局。然而，你肯定想避免这些可能发生的冲突：一般来说，如果一个视图的大小，默认为给定维度的固有内容大小，在这个维度下，你便可以安全的添加约束。关于“冲突的约束”的更多信息，查看3.2 不能满足的布局。 另外，我们可以把一个 stack view 嵌套到别的 stack view 们中去，以此打造更加复杂的布局。 一般来说，尽量多地使用 stack view 来管理你的布局。如果仅仅使用 stack view 无法实现我们想要的，再选择创建约束的方式来解决布局问题。 想要查看更多的关于 stack view 的信息，查看 UIStackView Class Reference和 NSStackView Class Reference。 NOTE 尽管嵌套使用 stack view 能做出复杂的用户界面，但是我们不能完全摆脱对 constraint 的需求。至少，在定义最外层 stack view 的位置的时候（也有可能是大小），我们总是需要使用 constraint 的。 解剖“一个约束”​ 视图层级的布局被定义成一系列的线形方程式。每个简单的方程式都代表一个约束。我们的目标是声明一系列的方程式，而且这些方程式有且只有一个解。 一个简单的方程式如下所示。 这个约束条件表明，红色视图的 leading edge 在蓝色视图的 tailing edge 后面 8 points 处。方程式包含以下几个部分： Item1. 方程式的第一个元素，就是上图中的 RedView ，这个位置只能是视图或者是一个 layout guide 。 Attribute 1. 第一个元素需要被约束的属性，就是上图中红色视图的 leading edge 。 Relationship. 方程式左右两侧的关系。可以是等于、大于等于、小于等于。上图左右两侧为相等关系。 Multiplier. Attribute 2 的值与这个浮点数 Multiplier 相乘。上图中，Multiplier 为1。 Item 2. 等式中的第二个元素，就是上图中的 blue view，第一个元素不能是空白，但是这个可以。 Attribute 2. 第二个元素需要被约束的属性，在上图中，就是蓝色视图的 trailing edge 。如果第二个元素是空白，Attribute 2 需要设置成 Not an Attribue（调用API时传的值）。 Constant. 一个常熟，浮点数偏移量。在上图中，就是8.0 。这个值要加到 Attribute 2 的值上去。 大部分的约束，就定义了我们用户界面中两个元素之间的关系。这些元素，可以是视图，也可以是 layout guide 。约束也可以定义同一个界面元素两个不同属性之间的关系。比如，设定一个元素的高宽比。我们也可以给元素的高、宽设定一个常数值。当涉及到设定常数值时，需要将第二个元素设置为空，Attribute 2 要设置成 Not an Attribue ，Multiplier 设置为 0.0 。 Auto Layout 属性​ 在 Auto Layout 中，属性，定义了一个特性，而这个特性可以被约束。一般来说，包括 4 种边缘， leading ，trailing ，top ，bottom，高度 、宽度 、水平中心 、垂直中心 。文本元素还多一个 baseline 属性。 想要了解完整的属性的列表，查看 NSLayoutAttribute 枚举。 NOTE 尽管 OS X 和 iOS 都用 NSLayoutAttribute 这个枚举，但是所包含的集合的值稍有不同。想要查看完整的属性的列表，确保查看的是正确的平台的文档。 方程式举例​ 对于约束方程式而言，其中的参数、属性可选值有很多，这就方便我们构建各种各样的约束。我们可以定义两个视图之间的间距，视图的边缘对齐，两个视图的大小关系，甚至定义一个视图的宽高比。但是，并不是所有的属性都能兼容的。 ​ 属性主要分为两种基本类型。 尺寸属性 （比如，宽、高）与 位置属性 （比如，leading ，left ，top等）。尺寸属性用来确定一个元素有多大，对它的位置信息丝毫不知情。位置属性用来确定一个与其他元素相关的元素的位置，对它的尺寸信息也毫不知情。 考虑到这些不同，下面的规则是适用的： 不能约束一个尺寸属性和一个位置属性之间的关系。 不能给位置属性设置常数值。 在操作位置属性是，不能使用非同一性的乘数（1.0 以外的值）。 对于位置属性来说，不能约束一个垂直属性和水平属性的关系。 对于位置属性来说，不能把 Leading 或者 Trailing 属性约束到 Left 或者 Right 属性上。 比如，设置一个元素的 Top 属性为常数值 20.0，如果没有额外的语境的话，这句话毫无意义。必须得定义一个元素的位置属性与其他元素的关系才行。比如，设置为在父视图的 Top属性 下面偏移 20.0 。相比之下， 设置一个元素的高为 20.0 是合法的。要看更多信息，查看 Interpreting Values 。 NOTE 所有的例子方程式都是用伪代码的方式呈现的，如果要查看约束适用的真正的代码，查看 4.1 编程的方式创建约束 or 2 Auto Layout 食谱. Listing 3-1 一些常见约束方程式的例子 123456789101112131415161718// Setting a constant heightView.height = 0.0 * NotAnAttribute + 40.0 // Setting a fixed distance between two buttonsButton_2.leading = 1.0 * Button_1.trailing + 8.0 // Aligning the leading edge of two buttonsButton_1.leading = 1.0 * Button_2.leading + 0.0 // Give two buttons the same widthButton_1.width = 1.0 * Button_2.width + 0.0 // Center a view in its superviewView.centerX = 1.0 * Superview.centerX + 0.0View.centerY = 1.0 * Superview.centerY + 0.0 // Give a view a constant aspect ratioView.height = 2.0 * View.width + 0.0 等式，不是赋值​ 值得注意的是，所显示的方程是表达左右相等关系的，不是赋值语句。 ​ 当 Auto Layout 处理这些方程式的时候，并不是简单地把方程式右侧的值赋值给左侧。Auto Layout 会计算 Attribute 1和 Attribute 2 的值来使方程式为真。这意味着，我们可以随意的调整方程式中元素的顺序。比如，列表 3-2 中的方程式和列表 3-1 中的表达式是一样的。 Listing 3-2 反转方程式 123456789101112131415// Setting a fixed distance between two buttonsButton_1.trailing = 1.0 * Button_2.leading - 8.0 // Aligning the leading edge of two buttonsButton_2.leading = 1.0 * Button_1.leading + 0.0 // Give two buttons the same widthButton_2.width = 1.0 * Button.width + 0.0 // Center a view in its superviewSuperview.centerX = 1.0 * View.centerX + 0.0Superview.centerY = 1.0 * View.centerY + 0.0 // Give a view a constant aspect ratioView.width = 0.5 * View.height + 0.0 NOTE 当调整方程式中元素的顺序时，请确保调整了 multiplier 和 constant。比如，一个 constant 为 8.0 应变成 -8.0 ，一个 multiplier 为 2.0 应该变成 0.5 。 Constant 为 0.0 ，multiplier 为 1.0 的情况不用做调整。 我们可以发现， Auto Layout 常常为解决一个问题提供多种解决方法。理想情况下，我们应该选择最能清晰描述我们目的的解决办法。然而，毫无疑问，不同的开发人员在那种解决方法最好上是不可能达成共识的。坚持自己比选择正确的还要重要。如果在长期使用的过程中，你只坚持使用同一种方法，那么将会极少遇到问题。比如，本 guide 采用以下几个 经验准则 ： 整数的 multiplier 比分数好。 正的 constant 比负的好。 不管在哪，视图应该按照布局的顺序出现，从 leading 到 trailing ，从 top 到 bottom 。 创建清晰的、可以满足的布局​ 当使用 Auto Layout 的时候，我们的目标就是提供一系列的方程式，这一系列方程式应该有且仅有一个可能的答案。产生歧义的约束有不止一种可能的答案。不能满足实现的约束没有可用的答案。 ​ 一般来说，约束们必须定义到每一个视图的尺寸和位置信息。假定父视图的的尺寸已经定了（比如，iOS中一个场景的根视图），一个不产生歧义的、能满足实现的布局要求每一个视图的每个维度都有两个约束（不算父视图）。然而，当选择要使用那个约束的时候，我们可选选项的范围很大。比如，下面三个布局均能创建不产生歧义的、能满足实现的布局（只展示了水平方向的约束）： 第一个布局约束视图的 leading edge 与其父视图的 leading edge 的关系。还给了视图一个确定的宽。基于父视图的尺寸和其他的约束，视图的 trailing edge 的位置就能被计算出来。 第二个布局约束视图的 leading edge 与其父视图的 leading edge 的关系。还约束视图的 trailing edge 与其父视图的 trailing edge 的关系。基于父视图的尺寸和其他的约束，视图的宽的值就能被计算出来。 第二个布局约束视图的 leading edge 与其父视图的 leading edge 的关系。约束视图与父视图水平居中。基于父视图的尺寸和其他的约束，视图的 宽、trailing edge 的位置就都能被计算出来。 我们能发现，每一个布局都是有一个 view 和两个水平方向的约束。每个情况下，约束都能完整地定义视图的宽的值、水平方向上的位置。这意味着，所有的布局均能沿着水平方向创建不产生歧义的、能满足实现的布局。但是，这三种布局的有用程度并不一样，比如，考虑父视图的宽变化的情况。 ​ 在第一种布局中，视图的宽并不会发上变化。大部分情况下，这样并不是我们想要的效果。实际上，普遍的规则是，我们应该避免给视图的尺寸赋固定的值。Auto Layout 的初衷就是创建可以动态随环境适应的布局。当你给了一个视图一个固定大小值的时候，这个能力就无用武之地了。 ​ 可能不是很明显，不过第二、第三种布局方式产生相同的行为：随着父视图的宽的变化，这两种布局方式都在视图与父视图之间维持了一个固定的间距。然而，他们不一定相等。一般情况下，第二个布局方式比较容易理解，但是第三种布局方式却更有用，特别是你需要居中对齐一部分元素的时候。和平常一样，为特定的布局选择最好的方式。 ​ 现在我们考虑复杂一点的东西。加入你想要展示两个视图，这俩视图挨着，在 iPhone 上。你想确保他们在每一侧都有一个不错的边距，这样的话，他们总是看起来有一样的宽。当设备旋转时，它们也应该正确的调整大小。 ​ 下面俩插图是这个视图在竖屏、横屏两种方向下的样子： 那他们的约束应该是什么样的呢？下面这个插图展示了一种比较直接的解决方案： 这种解决方案用了以下这些约束： 1234567891011// Vertical ConstraintsRed.top = 1.0 * Superview.top + 20.0Superview.bottom = 1.0 * Red.bottom + 20.0Blue.top = 1.0 * Superview.top + 20.0Superview.bottom = 1.0 * Blue.bottom + 20.0 // Horizontal ConstraintsRed.leading = 1.0 * Superview.leading + 20.0Blue.leading = 1.0 * Red.trailing + 8.0Superview.trailing = 1.0 * Blue.trailing + 20.0Red.width = 1.0 * Blue.width + 0.0 按照之前的 经验准则 ，这个布局有两个视图，应该有4个水平的约束和4个垂直的约束。尽管这不是一个绝对可靠的 guide，但它可以快速的暗示你你已经走上正轨。最重要的是，这些约束，独一无二地确定了两个视图的尺寸与位置，创建了一个不会产生歧义、能够满足实现的布局。移除任何一个约束，布局就会变得产生歧义。添加其他的限制，会有产生矛盾的风险。 不过，这并不是唯一可能的解决方案。这里有一个同样有效的方法: 与其固定蓝色视图的 top 和 bottom 到它的父视图上，我们可以将蓝色视图的 top 与红色视图的 top 对齐。类似的，你可以对齐两个视图的 bottom。这些约束如下所示。 1234567891011// Vertical ConstraintsRed.top = 1.0 * Superview.top + 20.0Superview.bottom = 1.0 * Red.bottom + 20.0Red.top = 1.0 * Blue.top + 0.0Red.bottom = 1.0 * Blue.bottom + 0.0 //Horizontal ConstraintsRed.leading = 1.0 * Superview.leading + 20.0Blue.leading = 1.0 * Red.trailing + 8.0Superview.trailing = 1.0 * Blue.trailing + 20.0Red.width = 1.0 * Blue.width + 0.0 我们发现，这个例子依旧是两个视图，4个水平方向上的约束，4个垂直方向上的约束。依旧能创建出不产生歧义、能满足实现的布局。 但是哪一个比较好呢？ 这两种方式均能创建有效的布局，哪个更好？ 很不幸，客观地证明一种方案是绝对优于另一种方案是不可能的。每一种方案都有优点和缺点。 第一种方案，具有较好的健壮性，比图当其中一个视图被移除了的情况。当从视图层级移除一个视图的时候，与这个视图相关的所有约束都会被移除。所以，如果你移除了红色视图，蓝色视图就剩下三个约束了，你需要添加一个简单的约束就能使布局可用。第二种方案下，删掉红色视图后，蓝色视图就剩一个约束了。 从另外的角度来说，第一种方案，如果你想让俩视图的 top 和 bottom 对齐，就必须确保他们的 top 和 bottom 使用相同的 常数值，如果修改了其中的一个，不要忘记修改另一个。 约束不等式​ 迄今为止，我们看到的所有关于约束的例子都是方程式等式，但这只是一部分。约束也能表达成不等式。准确的说，约束的关系可以是等于、大于等于、小于等于。 ​ 比如，我们可以使用约束来限定一个视图的最大尺寸和最小尺寸（Listing 3-3）。 Listing 3-3 设定一个最大、最小尺寸 12345// Setting the minimum widthView.width &gt;= 0.0 * NotAnAttribute + 40.0 // Setting the maximum widthView.width &lt;= 0.0 * NotAnAttribute + 280.0 ​ 只要一开始使用不等式，每个视图每个维度必须两个约束，这条规则就不好使了。对于一个等式，我们总能用两个不等式来替代。在 Listing 3-4 中，是一个简单的等式和一对能产生同样行为的不等式。 Listing 3-4 将一个等式关系替换成两个不等式关系 123456// A single equal relationshipBlue.leading = 1.0 * Red.trailing + 8.0 // Can be replaced with two inequality relationshipsBlue.leading &gt;= 1.0 * Red.trailing + 8.0Blue.leading &lt;= 1.0 * Red.trailing + 8.0 倒过来，将两个不等式替换成一个等式的情况，并不一定可以，因为两个不等式一般与一个等式不是等价关系。比如，Listing 3-3 中的不等式，限制了视图宽的一个可能的范围，但是并没有确定这个宽。在这个可能的范围智商，我们还是需要额外的水平约束才能定义这个视图的位置和尺寸。 约束的优先级​ 默认条件下，所有的约束都是 required 。Auto Layout 必须计算出一个满足所有约束的解决方案。如果不行的话，就会报错。Auto Layout 会把未能满足实现的约束信息打印到控制台，同时选择其中的一个约束来打破。然后，再去掉那个打破了的约束的情况下，Auto Layout 会重新计算解决方案。想要了解更加详细，查看3.2 不能满足的布局。 ​ 你也可以创建 optional 约束。所有的约束都有一个优先级，优先级从 1 到 1000 。优先级为 1000 的约束就是 required 的。所有的其他的约束是 optional 的。 ​ 当计算解决方案的时候， Auto Layout 会尝试去满足所有的约束，不过是按照优先级从最高到最低的顺序。如果它没有办法满足一个 optional 的约束的话，就会跳过那个约束，继续下一个约束。 ​ 即使一个 optional 的约束没能被满足，它仍然可以影响布局。如果跳过这个约束后，出现了歧义，系统会选择最接近约束的解决方案。这种情况下，不能满足实现的 optional 约束表现的像一个力一样拉着视图接近它们。 ​ optional 的约束经常和不等式紧密合作。比如，在 Listing 3-4 中，你可以给两个不等式提供不同的优先级。大于等于关系的那个不等式可以设置为 required （优先级1000），小于等于关系的可以设置成一个较低的优先级（优先级250）。这意味着蓝色视图不能里离红色视图比 8.0 还近。然而，其他的约束可能会把它拉的更远。不过，考虑到布局中的其他约束， optional 的约束还是会把蓝色视图拉向红色视图，确保它尽可能的离 8.0 的间隔近一点。 NOTE 不要觉得有义务使用所有的 1000 个优先级的值。实际上，优先级一般应该聚集在系统定义的 low（250），medium（500），high（750），required（1000）这些优先级上。你也许需要创建比这些值大或者小 1、2 的优先级的约束，有助于防止关系（prevent ties）。如果的需要是远远地超出这个范围，那么您可能需要重新检查你的布局逻辑了。 如果需要查看 iOS 中预定义好的约束常量的完整列表，查看 UILayoutPriority 枚举。对于 OS X，查看 Layout Priorities constants。 固有内容尺寸大小​ 迄今为止，所有的例子都使用约束来定义视图的位置和大小。然而，一些视图根据他们目前的内容，就有自然的尺寸大小。这个指的就是它们的 固有内容大小 。例如，一个按钮的固有内容大小是它的文字标题的大小加上一点的间距。 ​ 并不是所有的视图都有固有内容大小。对于有这个的视图来说，固有内容大小可以定义视图的高，或者宽，或者两者都可以。表格 3-1 是一些例子。 Table 3-1 常见控件的固有内容尺寸 VIew 固有内容尺寸 UIView、NSView 没有 Sliders 仅仅定义了宽（iOS）定义了宽、高，或者两者都定义了，这取决于 Slider的类型（OS X） Labels、Buttons、Switches、Text Fields 定义了高度和宽度 Text views、Image views 固有内容大小会有所不同 ​ 固有内同大小是基于视图的当前内容的。一个 Label 或 Button 的固有内容大小是由所展示文本的量和字体决定的。对于其他的视图，固有内容大小更加复杂。比如，一个空的 Image View 没有固有内容大小。只要你添加了一张图片进去，它的固有内容大小就会变成这个图片的尺寸。 ​ 一个 Text View 的固有内容大小会根据内容的不同而不同，也会根据 scrolling enabled 的值的不同而不同，还会受到其他约束的影响。比如，如果一个 Text View 的 scrolling enabled 为 YES，那么它就没有固定内容尺寸大小。scrolling enabled 为 NO 时，默认这个 Text view 的固有内容尺寸大小是基于文本（不包括自动换行 ）的尺寸计算的。例如，如果文本中没有回车的话，Text View 就计算以单行文本形式布局内容所需要的高、宽。如果你添加了约束来确定视图的宽，那固有内容大小会根据这个宽来给出展示文本内容所需要的高度值。 Auto Layout 使用每个维度一对约束来表示一个视图的固有内容大小。Content-Hugging （内容拥抱）将视图向内拉，这样视图就很好的紧贴内容四周。Compression-Resistance （压缩阻力）把视图往外推，这样的话视图就不会切割内容。 在列表 3-5 中，约束以不等式的形式呈现。在这里， IntrinsicHeight 和 IntrinsicWidth 常量代表的是视图的固有内容大小的高、宽的值。 List 3-5 压缩阻力和内容拥抱方程 1234567// Compression ResistanceView.height &gt;= 0.0 * NotAnAttribute + IntrinsicHeightView.width &gt;= 0.0 * NotAnAttribute + IntrinsicWidth // Content HuggingView.height &lt;= 0.0 * NotAnAttribute + IntrinsicHeightView.width &lt;= 0.0 * NotAnAttribute + IntrinsicWidth 这些约束，每一个都可以有自己的优先级。默认条件下，视图的 Content-Hugging 使用 250 的优先级，Compression-Resistance 使用750的优先级。因此，拉伸一个视图比压缩它要容易的多。对于大部分控件来说，这正是我们期望的行为。比如，你可以安全地拉伸一个按钮，拉伸到比他的固有内容尺寸还要大，但是，如果你压缩它，它的内容很可能会被切掉。请注意，Interface Builder 可能会偶尔修改这些优先级，为的就是防止关系（prevent ties）。想要获取更多信息，查看1.4.5 设置 Content-Hugging 和 Compression-Resistance 优先级。 无论何时，尽可能地在你的布局中使用固有内容大小。这会使你的布局随着视图内容的改变可以动态地调整。这样的话，在创建不产生歧义、没有矛盾的布局的过程中，能够减少我们需要的约束的数量，但是我们需要管理视图的 Content-Hugging 和 Compression-Resistance 属性（CHCR）。下面是一些处理固有内容大小的指导方针。 当为了填充一个空间而拉伸一系列的视图的时候，如果所有的视图有一样的 Content-Hugging 属性，布局就会产生歧义。Auto Layout 不知道该去拉伸哪个 view。一个普遍的例子就是，Label 和 Text Field 这一对。一般情况下，我们想让 Text Field 拉伸来填充多余的空间，让 Label 保持它固有内容尺寸大小。为了达到这个效果，应确保 Text Field 的水平 Content-Hugging 优先级比 Label 的Content-Hugging 优先级低就好了。实际上，这个例子十分普遍，以至于 Interface Builder 可以自动处理，它会把所有 Label 的 Content-Hugging 优先级设置为 251。如果你是通过编程的方式编辑你的布局，你得自己修改 Content-Hugging 优先级。 当拥有不可见背景的视图（ 如 Button 和 Label ）意外被拉伸得超过他们固有内容大小的时候，就会发生奇怪的、意料之外的布局。实际的问题可能并不明显，因为文本只是出现在了错误的位置。为了避免我们不想要的拉伸，应该增大 Content-Hugging 优先级。 Baseline 约束只适用于正处于固有内容大小高度的视图。如果一个视图在垂直方向上被拉伸或者压缩，baseline 约束便不再正确的对齐。 一些视图，比如 Switches ，只应该以固有内容尺寸大小出现。按需增加它们的 CHCR 优先级，来避免被拉伸或压缩。 避免赋给视图 required 的 CHCR 优先级。对于一个视图来说，错误的尺寸比不小心产生冲突的情况要好得多。如果一个视图应该始终是其固有的内容尺寸大小，那么可以考虑使用非常高的优先级(999)。这种方法通常使视图不被拉伸或压缩，但仍然提供紧急压力阀，以防止你的视图在一个环境中显示的比我们预想的大或者小。 固有内容尺寸 VS Fitting Size ​ 固有内容尺寸大小像是 Auto Layout 的输入。当一个视图拥有固有内容尺寸大小时，系统会生成约束来表示这个大小，而且使用这个约束来计算布局。 ​ 在另一方面，fitting size 是 Auto Layout 引擎的输出。是针对一个视图基于它的约束计算出来的大小。如果一个视图使用 Auto Layout 布局它的子视图，系统也许能基于它的内容计算出一个 fitting size 。 ​ Stack View 是一个较好的例子。除非有其他的约束，否则的话，系统基于 Stack View 的内容和属性计算它的大小。从很多方面来看，堆栈视图就好像有一个固有内容尺寸大小：你可以使用单个垂直和单个水平约束来定义其位置，从而创建有效的布局。但是，它的大小是 Auto Layout 计算出来的 — 它并不是 Auto Layout 的输入。设置 Stack View 的 CHCR 优先级没有什么作用，因为 Stack View 并没有一个固有内容尺寸大小。 ​ 如果你需要根据 Stack View 外相关的东西，来调整 Stack View 的 fitting size ，要么创建显式约束来捕获这些关系，要么修改，与 Stack View 外东西相关的 Stack View 内容的 CHCR 优先级。 解释 Auto Layout 属性的 ” 值 “​ Auto Layout 中的值，都是以 point 为单位。然而，这些度量的确切含义取决于所涉及的属性和视图的布局方向。 Auto Layout Attributes Value Notes Height、Width 视图的大小 这俩属性可以被分配为常量值，或者与其他高度和宽度属性相结合。这俩属性值不能为负数。 Top、Bottom、Baseline 这些值，随着王屏幕下方的移动，都增加。 这几个属性只能与 Center Y、Top、Bottom、Baseline 这些属性结合。 Leading、Trailing 这俩值随着你向尾部移动，均增加。对于一个从左到右的布局方向来说，随着向右移动俩值增加。对于一个从右到左的布局方向来说，随着向左移动，俩值增加。 这俩属性只能与 Center X、Leading、Trailing 这些属性结合。 Left、Right 随着你向右移动，俩值增加。 这俩属性只能与 Center X、Left、Right 这些属性结合。但是应该避免使用 Left 和 Right 属性，而是使用 Leading 和 Trailing 属性。这样使得布局能够适应视图的阅读方向。默认阅读方向是由用户选择的当前语言决定的。然而，必要时可以 override 。在 iOS 中，设置持有约束的视图（所有受到约束影响的最近的公共祖先）的 semanticContentAttribute 属性，来确定在从左到右的语言还是从右到左的语言之间切换的时候，内容的布局是否需要翻转。 Center X、Center Y 这俩值的意思得基于方程式等式中的另外一个属性。 Center X 可以和 Center X、Leading、Trailing、Right、Left 属性结合。Center Y 可以和 Center Y、Top、Bottom、Baseline 属性结合。 在 Interface Builder 中使用约束​ 在 Interface Builder 中，有三种方法可以设置 Auto Layout 约束：你可以在视图之间 control-drag ，你可以使用 Pin 和 Align 工具，你也可以让 Interface Builder 为你设置约束，然后再自己去编辑、修改为你设置的约束。每一种方法都有自己的优点和缺点。大部分开发人员都会认为一个方法比其他俩好，但是如果对三种方法都很熟悉的话，便可以根据手头的任务快速切换工具。 ​ 这三种方法，都是从“把 Object Library 中的视图和控件拖到场景里来” 开始的。按照自己的需求，调整他们的大小、位置。当您在画布上放置视图时，Interface Builder 会自动创建一组原型约束，定义视图当前大小和相对于左上角的位置。 ​ App 可以通过这些原型约束构建和运行。使用这些约束快速地可视化和测试用户界面，然后用您自己的显式约束替换隐式约束。永远不要用原型化的约束来发布应用程序。一旦您创建了第一个约束，系统就会从约束所引用的视图中移除所有的原型约束。如果没有原型约束，您的布局就不再有足够的约束来赋值给所有视图唯一的大小和位置。它变成了一个模糊的、有歧义的布局。受影响的约束会以红色出现，Xcode同时生成许多警告。 ​ 不要慌，继续添加约束，知道我们的布局完整。只要添加了一个约束，你就有责任添加 “创建一个没有歧义的、能满足实现的布局所需要的” 所有的约束。 ​ 想要了解更多关于修复布局警告 ⚠️ 和错误 ❌ 的内容，查看 3 调试 Auto Layout。 Control-拖拽约束​ Control-点击一个视图，然后拖至另外一个视图，以此来创建两个视图的约束。 当你松开鼠标的时候，Interface Builder 会弹出一个弹窗菜单，展示的是一系列可选的约束。 Interface Builder 会根据你约束的元素和拖拽手势的方向，智能地呈现可选约束的集合。如果你大概是水平方向上的拖拽，就会展示 设置水平间隔 、垂直对齐视图 的选项。如果你大概是竖直方向上的拖拽，就会展示 设置垂直间距 、水平对齐视图 的选项。这两种手势也都包含其他的可选的约束（比如设置视图的大小相关性）。 NOTE 你可以对画布里的一个个元素使用 control-拖拽 手势，也可以对场景文档大纲里面的一个个小图标使用。对于在画布中比较难找的元素（比如 top layout guide 或者 bottom layout guide ），这个方法就很有帮助了。当你在文档大纲里面 control-拖拽 的时候，Interface Builder 就不会基于拖拽方向筛选可选的约束了。 ​ Interface Builder 基于视图当前的 frame 创建约束。因此，在拖拽约束之前，需要小心翼翼地准确地定位视图。如果你是根据 Interface Builder 的指导方针来连接视图们，最终应该得到的是一组合理的约束。必要时，你可以随后编辑修改这些约束。 ​ Control- 拖拽 提供了一个创建约束的便捷方法；然而，因为约束的值是根据场景当前的布局推导出来的，很容最后得到的是固定的 point 值。如果想要更好的控制，在创建它们之后检查和编辑约束，或者使用 Pin 和 Align 对齐工具。 ​ 更多关于 control-拖拽 约束的信息，查看 Adding Layout Constraints by Control-Dragging in Auto Layout Help。 使用 Stack、Align、Pin 和 Resolve 工具​ Interface Builder 提供了4种 Auto Layout 工具，它们位于编辑窗口的右下角。分别是 Stack，Align，Pin，Resolve Auto Layout Issue tools。 当你想很好的控制添加约束的过程或者当你往一次添加多个约束的时候，应该使用 Pin 和 Align 工具。作为一个额外的优势，当您使用这些工具时，您不需要在创建约束之前精确地放置你的视图。相反，你可以大概地放一下视图的相对位置，添加约束，然后 update the frame。这让 Auto Layout 为您计算正确的位置。 Stack Tool ​ Stack 工具让我们可以快速的创建一个 Stack View。选择你布局中一个或者多个元素，然后点击 Stack 按钮。Interface Builder 将选中的项嵌入 Stack View 中，并根据其内容对当前的 fitting size 进行调整。 NOTE 系统从视图的初始相对位置推断 Stack View 的轴和对齐方式。我们可以通过属性检查器修改轴和对齐方式（也能设置分布方式和间隔）。 Align Tool ​ Align Tool 让我们可以快速的对齐布局中的项们。选中你想对齐的那些项，点击 Align 按钮。Interface Builder 弹出一个视图，其中包含许多种对齐方式。 ​ 选中用于对齐所选视图的选项，并单击添加约束按钮。Interface Builder 创建所需的约束，以确保这些对齐。默认情况下，约束没有任何偏移量(边界或中心是彼此对齐的)，当添加约束时，没有任何 frame 被更新。您可以在创建约束之前更改这些设置。 ​ 一般的，在使用 Align 工具时，你要选择两个或者更多的视图。然后，水平容器约束和垂直容器约束可以被添加到仅一个视图上。你可以使用弹出视图来一次性创建任意数量的约束，尽管每次只创建多于一个或两个的约束是没有意义的。 ​ 要了解更多信息，请参见 Auto Layout Help 中的 Adding Auto Layout Constraints with the Pin and Align Tools。 Pin Tool ​ Pin tool 让你可以快速地定义一个视图相对于他的旁边视图的位置，也可以快速定义这个视图的大小。选择您想要确定的位置或大小的项，然后单击 Pin 按钮。Interface Builder 提供一个包含许多选项的弹窗视图。 ​ 弹窗视图的上部分让你可以固定所选项的 Leading、Top、Trailing、Bottom的边缘到旁边视图上。相关的那个数字指的是画布中这两个项目前的间距。你可以输入一个自定义的间隔，或者你可以点击一侧的小三角展开按钮，来设置你想让当前视图约束到哪个视图上或者是选择一个标准间隔。 “Constrain to margins ” 选择框决定了所选视图约束到父视图的关系是否使用父视图的边距或者他自己的边缘。 ​ 弹窗靠下一点的部分让你设置选中项的宽、高。宽度和高度约束默认为当前画布中的大小，尽管您可以输入不同的值。Aspect Ratio （宽高比）约束也使用选中项当前的宽高比。然而，如果你想修改这个宽高比，你需要在创建之后再检查和编辑。 ​ 一般来说，我们选择一个视图来固定。然而，你也可以选择两个甚至更多的视图然后给他们设置等宽或者等高的约束。你也可以一次添加多个约束，或者你可以在添加约束时 update the frames。在设置了你想设置的选项之后，点击添加约束按钮来创建约束。 ​ 要了解更多信息，请参见 Auto Layout Help 中的 Adding Auto Layout Constraints with the Pin and Align Tools。 Resolve Auto Layout Issues Tool ​ Resolve Auto Layout Issues 工具提供了一些选项来修复常见的 Auto Layout 问题。弹窗视图上半部分选项只对当前选中的视图起作用。下半部分的选项对场景中所有的视图都起作用。 ​ 你可以基于当前的约束update the frame，或者你可以给予视图当前在画布中的位置来更新约束。你也可以添加确实的约束，清除约束，或者重新按照 Interface Builder 的建议设置约束。关于添加约束、充值约束的命令，在1.4.3 让 Interface Builder 创建约束 中有更详细的说明。 让 Interface Builder 创建约束​ Interface Builder 可以帮我们创建一些甚至是全部的约束。当使用这种方式的时候 ，Interface Builder 会根据视图当前在画布中的位置和大小，尝试推算出最好的约束。用这种方式时，要小心地设定视图的位置，因为一点点的间隔上的不同可能会导致 Auto Layout 给我们创建非常不一样的布局。 ​ 点击 Resolve Auto Layout Issues tool &gt; Reset to Suggested Constraints 来让 Interface Builder 给我们创建约束。Interface Builder 会给我们选中的视图（或者是场景中的所有视图）创建全部都是 required 的约束。 ​ 或者，我们可以自己添加一部分约束，然后点击 Resolve Auto Layout Issues tool &gt; Add Missing Constraints。为了得到一个没有歧义的、清晰的布局，这个选项会把需要添加的约束都添加上。同样，我们可以对选中的视图添加，也可以对所有视图一起添加约束。 ​ 这种方式可以让我们迅速的建立一个没有歧义、能满足实现的布局。但是除非用户界面比较简单直接，导出的布局可能并不是你想要的样子。要一直测试用户界面，并修改约束，直到得到预期的结果。 查看并编辑约束​ 在添加约束之后，我们得能找到它、查看它、编辑它。访问到约束有以下几种方式，每一种方式都提供了一种特有的组织约束、呈现约束的方法。 查看画布中的约束 ​ 编辑窗口，把影响所选视图的所有约束，在画布上以有色线条的形式展示出来。形状、描边类型和线条的颜色可以告诉你很多关于约束当前状态的信息。 I-bars（带有T形线帽的线） I-bars 展示的是一个间距的大小。这个间距可以是两个元素之间的距离，也可以是一个元素的高、宽。 Plain lines（直线，没有线帽） Plain lines 展示的是边缘对齐的位置。比如，Interface Builder 在对齐两个或者多个视图的 leading edge 时，使用一条简单的线。这些线也可以用来连接两个没有间隔的项。 Solid Lines. 实线代表优先级为 1000 的 required 约束。 Dashed Lines. 虚线代表可选的约束，优先级小于 1000。 Red Lines. 受这个约束影响的一个项发生了错误。要么这个项出现了歧义的布局，要么就是布局没有能够满足实现。想要获得更多信息，查看 issue navigator 或者 Interface Builder 大纲右上角的展开箭头。 Orange Lines. 橙色线表示受此约束影响的一个项的 frame 在当前的这些约束条件下不处于正确的位置。Interface Builder 也展示了计算出的 frame 位置，是用虚线表示的。 Blue Lines. 受到这个约束影响的好多项，有了一个没有歧义的、能满足实现的布局。而且这些项的 frame 正处于 Auto layout 计算出的正确的位置上。 Equal Badges. 对于让两个项等宽的约束，或者是等高的约束，Interface Builder 以断开的线条的形式呈现约束。这两个断开的线条中间用一个中间有 “=” 的徽章连接在一起。 Greater-than-or-equal and less-than-or-equal badges. Interface Builder 中对于所有表示大于等于和小于等于的约束关系，用一个蓝色的带有 “&gt;=” 或者 “&lt;=” 标志的徽章来标记这个约束。 在文档大纲中罗列约束 ​ 在文档大纲中，Interface Builder 罗列出了所有的约束，分别放在持有他们的视图的下面，达到分组的效果。包含约束关系中的两个项的最近的视图（最近的公共父视图）持有这个约束。这样计算的话，每个视图包含自己和所有子视图，top layout guide 和 bottom layout guide 被场景的根视图包含。 尽管约束可以围绕文档大纲展开，但大多数约束最终都在场景的根视图下。如果你想确认你找到了所有约束，那么就展开整个视图层级结构。 ​ 约束以伪代码的形式被列举出来。这列表往往很长，而且它们通常以一组相似的视图开始，因此在看到有意义的信息之前，您可能需要增加outline的宽度。在文档大纲里面选择一个约束，这个约束会在画布中高亮。用这个特性可以帮助我们快速的找到我们想要检查的约束。 ​ 对于一个简单的场景来说，大纲是一个最棒的地方，方便我们浏览场景所有的约束。但是，随着布局变得更加复杂，想要快速找到某个约束就变的很困难。最好常常一次检查一个视图的所有约束，可以通过在画布中选中这个视图或者在尺寸检查器中检查这个视图。 在尺寸检查器中找到约束 ​ 尺寸检查器列出了影响当前选中视图的所有约束。required 约束以实线框的形式呈现，可选的约束用虚线。描述部分列举出了关于这个约束的重要信息。常常包括被影响的属性和约束关系中其他的项。也有可能包括关系、常数值、乘数（multiplier）或者比例。 ​ 上图的顶部的示意图表示哪些属性受到了约束的影响。你可以选择一个或者多个（command + click）的示意图属性，以此来筛选下侧的约束列表。列表只会显示那些能影响 选中的属性 的约束。 ​ 想要了解更多，查看 Auto Layout Help 中的 Viewing the Complete List of Layout Constraints for an Item。 检查、编辑约束 ​ 当你选中一个约束的时候，不管是从文档大纲里，还是从画布上，属性检查器会显示这个约束的所有属性。这包括约束方程式的所有值：第一个元素、等式关系、第二个元素、常量、和乘数（multiplier）。属性检查器也会显示这个约束的标识符和优先级。 NOTE 约束的标识符属性让你提供一个具有描述性质的名字，这样的话，你可以更容易的在控制台日志和其他调试任务中定位到你的约束。 ​ 你也可以将约束标记为 占位符。这些约束只存在于设计期。当App运行时，布局中并不包含这些约束。一般在你打算在运行时动态的添加约束时，才会用到 占位符约束。你可以，通过临时添加必要的约束来创建一个没有歧义的、可满足实现的布局，来清除 Interface Builder 中的任何警告或错误。 ​ 你可以随意地修改常量、优先级、乘数、等式关系、标识符和占位符约束。对约束中的第一、第二个元素来说，你的选项就比较有限了。你可以交换第一、第二个元素（如果需要，得反转乘数和常量）。我们还可以修改第一、第二个元素的属性，但是不能修改这两个元素本身。如果你想将约束转移到另一个完全不同的元素上，只能删除这个约束，用一个全新的约束代替它。 ​ 在 尺寸检查器 中，有一些编辑操作是直接可用的。点击任何一个约束右边的 “edit” 按钮，会弹出一个弹窗，在这个弹窗中，我们可以修改约束的等式关系、常量、优先级、乘数。想要做一些额外的修改，双击选中约束，然后在 属性检查器 中打开它，进行编辑。 ​ 想要了解更多，查看 Auto Layout Help 中的 Editing Auto Layout Constraints。 设置 Content-Hugging 和 Compression-Resistance 优先级​ 为了设置一个视图的 Content-Hugging 优先级 和 Compression-Resistance 优先级 （CHCR 优先级），得先通过画布或者是在文档大纲选中这个视图。打开尺寸检查器，滚动到设置 Content-Hugging、 Compression-Resistance 优先级的地方。 ​ 你也可以在 Interface Builder 中设置视图的固有大小。默认情况下，Interface Builder 使用视图的 intrinsicContentSize 方法返回的大小。然而，如果在设计期你需要一个不同的大小，你可以设置一个 占位符固有内容大小 。这个占位符只会在 Interface Builder 中影响视图的尺寸。对运行时的视图没有任何影响。 ​ 想要了解更多，查看 Auto Layout Help 中的 Setting the Placeholder Intrinsic Size for a Custom View。 iOS特有的特性​ iOS 添加了一些在与 Auto Layout 交互过程中特有的特性。包括 top layout guide 和 bottom layout guide，一个视图的 layout margin，一个视图的 readable content guides ，一个视图的 semantic content （语义内容）。 Top and Bottom Layout Guides ​ top layout guide 和 bottom layout guide 代表的是当前活跃的视图控制器的可视内容区域上下边缘。如果你不想让你的内容扩展到透明或者半透明的 UIKit bars（比如，状态栏、导航栏、tab 栏）之下，用 Auto Layout 把你的内容固定到相关的 layout guide 。 ​ layout guide 采用了 UILayoutSupport 协议，guide 有一个 length 属性，这个属性衡量的是 guide 和相关的边缘的距离。特别地： 对于 top layout guide 来说， length 属性意味着距离，以 point 为单位，在视图控制器的视图顶部，和覆盖视图的最低的栏的底部（最低是因为上面会出现多个栏的情况，状态栏、导航栏等），之间的距离。 对于 bottom layout guide 来说， length 属性意味着距离，以 point 为单位，在视图控制器的视图底部，和覆盖视图的栏的顶部，之间的距离。 这些 guides 可以表现的像约束中的一个元素一样，支持 top、bottom、height 等属性。比较典型的做法是，我们约束视图到 top layout guide 的bottom 属性，或者约束到 bottom layout guide 的 top 属性。guide 也提供了 topAnchor、bottomAnchor、heightAnchor 属性，来简化编程创建约束的难度。 ​ 当创建与根视图的 top边缘 或者 bottom 边缘约束时，Interface Builder 会自动的将 top、bottom layout guide 作为选项。如果 layout guide 是视图最近的邻居， Interface Builder 会默认使用 layout guide。当使用 Pin 工具时，如果需要的话，你可以在 layout guide 和 根视图的边缘之间切换。 点击小三角展开按钮就可以了。 Layout Margins ​ Auto Layout 为每一个视图都定义一些边距。这些边距描述了视图边缘和子视图之间的首选间距。你可以通过 layoutMargins 或者 layoutMarginsGuide 属性访问视图的边距。layoutMargins 属性让你可以以 UIEdgeInsets 的结构 get、set 边距的值。layoutMarginsGuide 属性提供了一个只读的入口，读取到一个 UILayoutGuide 对象。另外，使用 preservesSuperviewLayoutMargins 属性来决定视图的边距如何与父视图的边距交互的。 ​ 默认的边距是一边8个 points 。你可以根据 App 的需求来修改这些边距。 NOTE 系统设置和管理根视图控制器视图的边距。顶部和底部的边距都设置成 0 ，使得扩展内容到 bar 之下变得很容易（如果需要的话）。侧面的边距会根据视图控制器出现的方式、位置而有所不同，但是要么是16 points，要么是 20 points。这些边距的值我们不能修改。 当约束一个视图与它父视图的关系的时候，一般我们使用 layout margin 而不是视图的边缘。在 UIKit 中，NSLayoutAttribute 枚举定义了一些属性来代表 top、bottom、leading、trailing、left、以及 right 这些的边距。还包括了 X中心、Y中心与边距相关的属性。 ​ 在 Interface Builder 中，control-拖拽一个视图与父视图之间的约束，默认使用边距属性。当使用 Pin 工具的时候，你可以选中 “Constrain to margin” 的选择框。如果选中了，导出的约束会使用父视图的边距属性。如果没有选中，会使用父视图的边缘（edge）。类似的，当在属性检查器中编辑一个约束的时候，第一个元素和第二个元素的展开菜单包括一个 “关联到边距” 选项。选中这个选项，来使用边距属性。不选这个选项，用的就是边缘（edge）。 ​ 最终，当以编程的方式创建到父视图边距的约束时，使用 layoutMarginsGuide 属性，直接创建与 layout guide 的约束。着让你使用 guide 的布局锚点来创建约束，提供了一种流线型、易读的API。 Readable Content Guides ​ 视图的 readableContentGuide 属性包括了一个 layout guide ，这个 layout guide 定义了在这个视图内部文本对象的最佳宽度值。理想情况下，内容应该足够窄，这样用户阅读的时候可以不用转动他们的小脑袋了。 ​ 这个 readableContentGuide 总是在视图的 layout margin 内居中，而且永远不会超出这些视图的边距。这个 guide 的大小会因为系统动态字体的大小不同而有所不同。当用户选择更大的字体时，系统就会创建更宽的 readableContentGuide ，因为用户一般阅读的时候都会把设备拿的离自己很远。 ​ 在 Interface Builder 中，你可以设置视图的 margin ，是代表 layout margins 还是 readableContentGuide 。 选择视图（一般是视图控制器的根视图），打开尺寸检查器。如果你选中了 Follow ReadableWidth 选择框，所有到视图 margin 的约束都会被 readableContentGuide 取代。 NOTE 对于大部分设备来说，layout margins 和 readableContentGuide 只有很小的区别或者没有区别。这个区别只有在使用 iPad 的横屏方向时才会比较明显。 Semantic Content ​ 如果你使用 leading、trailing 约束来布局你的视图的话，在从左到右的语言（英语）和从右到左的语言（阿拉伯语）之间切换时，视图会自动翻转位置。然而，一些界面元素不应该随着阅读方向改变它们的位置。例如，基于物理方向（上、下、左、右）按钮，应该一直保持在相同的相对方向。 ​ 视图的 semanticContentAttribute 属性决定了，当语言阅读方向切换时，视图的内容是否应该反转。 ​ 在 Interface Builder 中，在属性检查器中设定语义选项。如果值是 Unspecified，视图的内容随着阅读方向反转。如果值为 Spatial、Playback、Force Left-to-Right 时，内容总是 leading edge 在左，trailing edge 在右。Force Right-to-Left 总是内容 leading edge 在右，trailing edge 在左。 经验法则​ 下列的指导方针会让你在自动布局中取得成功。毫无疑问，每个规则都有一些合法的例外。然而，如果你决定离开他们，那么在继续之前，停下来仔细考虑一下你的方法。 不要使用 frame、bounds、center等属性来确认视图的几何信息。 尽可能的使用 Stack View 。Stack View 管理它内容的布局，极大的简化了剩下布局所需的约束逻辑。只有在 Stack View 不能提供你需要的行为时，再自定义约束。 创建一个视图和离它最近的邻居之间的约束。如果你有两个相邻的 button ，约束第二个按钮的 leading edge 到 第一个按钮的 trailing edge。第二个按钮一般不应该有跨过第一个按钮直接与视图边缘的约束关系。 避免给视图一个固定的高、宽。Auto Layout 的全部意义就是动态响应改变。给视图一个固定的大小就会让视图损失这个适应的能力。然而，你可能想给视图一个最大最小的尺寸范围。 如果你设置约束时遇到困难，是这是用 Pin 和 Align 工具。尽管这些工具可能用起来比 control-拖拽 要慢一些，但是他们确实让你在创建约束之前就能验证确切的值和所涉及的项。这种额外的检查是有帮助的，特别是当你刚开始的时候。 当自动更新一个项的 frame 时，要小心。如果这个项没有足够的约束来完整地确定它的尺寸和位置，这时候 update 行为就是未定义的。视图经常消失，要么因为他们的高或者宽被设置成 0 或者因为他们意外地跑到屏幕外边去了。 确认布局中的所有视图都有一个有意义的名字。这个会让使用工具时定位某个视图容易的多。系统会根据 Label、button 上的文本、标题自动给它们命名。对于其他视图来说，你可能需要在身份检查器中设置一个 Xcode中的特定标签 （或者通过在文档大纲中双击编辑视图的名字）。 总是使用 Leading、trailing 约束而不是 Left、Right 约束。你总是可以，通过 semanticContentAttribute 属性（iOS）或者 userInterfaceLayoutDirection 属性（OS X），调整视图如何解释 leading edge、trailing edge 。 在 iOS 中，当需要把一个项约束到视图控制器的根视图的边缘，我们使用以下的约束： Horizontal constraints. 对于大部分控件，使用一个值为 0 point 的到 layout margins 的约束 。系统会根据具体的设备和App展示的视图控制器，自动提供正确的间隔。对于从 margin 到 margin 填充根视图的文本对象，使用 readable content guides 而不是 layout margins。对于需要从边缘到边缘填充根视图的视图，使用它的 leading edge 和 trailing edge。 Vertical constraints. 如果视图扩展到 bar 下面，使用 top margin 和 bottom margin。对于滚动视图来说，这个尤其普遍，这允许内容可以滚动到 bar 的下面。请记住，然而，你可能需要修改滚动视图的 contentInset 和 scrollIndicatorInsets 属性来正确地设定内容的初始位置。如果想视图不要扩展到 bar 的下面，把视图约束到 top layout guide 和 bottom layout guide 上。 当以编程的方式实例化视图时，确保把视图的 translatesAutoresizingMaskIntoConstraints 属性设置为 NO。默认情况下，系统会基于视图的 frame 和它的 autoresizing mask ，自动地创建一组约束。当你添加自定义的约束时，它们不可避免地与自动生成的约束发生冲突。这就会创建出一个不能满足实现的布局。 知道 iOS 和 OS X计算他们布局是不同的。在 OS X中，Auto Layout 能修改窗口的内容，也能修改窗口的大小。在 iOS 中，系统提供场景的大小和布局。Auto Layout 只能修改场景的内容。这些不同之处看起来没啥，却会对你如何设计布局产生深远的影响，尤其是你如何使用优先级上。 2 Auto Layout 食谱Stack Views​ 下面这篇展示了如何使用 Stack View 来创建日益复杂的布局。对于快速、简单地设计我们的用户界面，Stack View 是一个强有力的工具。Stack View 的属性们让我们可以高度控制它如何布局它的 arranged views。你可以通过使用附加的自定义约束来增加这些设置；然而，这会增加布局的复杂性。 ​ 想要查看本章用到的源代码，查看 Auto Layout Cookbook 工程。 简单 Stack View​ 下图使用一个单独的、垂直 Stack View 来布局一个 Label、Image View 和一个 button。 视图与约束 ​ 在 Interface Builder 中，从拖拽出一个垂直 stack view 开始，然后添加 “flower” label、image view 和 “edit” button。然后像下图展示的这样设置约束。 Stack View.Leading = Superview.LeadingMargin Stack View.Trailing = Superview.TrailingMargin Stack View.Top = Top Layout Guide.Bottom + Standard Bottom Layout Guide.Top = Stack View.Bottom + Standard 属性 ​ 在属性检查器中，设置 Stack View 的以下属性。 Stack Axis Alignment Distribution Spacing Stack View Vertical Fill Fill 8 ​ 然后，设置 Image View 的以下属性： View Attribute Value Image View Image （一个花的图片） Image View Mode Aspect Fit ​ 最后，在尺寸检查器里，设置 Image View 的 content-hugging and compression-resistance（CHCR）优先级。 Name Horizontal hugging vertical hugging Horizontal resistance Vertical resistance Image View 250 249 750 749 ​ 讨论 ​ 你必须把 Stack View 固定到父视图上。但是另一方面，Stack View 管理整个布局，没有任何其他显式的约束。 ​ 在这篇中，stack view 用一个较小的、标准的边距，填充它的父视图。排列的视图的大小会被被调整以填充Stack View 的边界。为了匹配 stack view 的宽，每个视图都被水平拉伸了。垂直方向上，视图基于他们自己的 CHCR 优先级被拉伸。Image View 应该总是压缩和拉伸，来填充可用的空间。因此，Image View 垂直方向上的 content-hugging （易拉伸）和 compression resistance（易压缩） 优先级必须得比 label 和 button 的默认优先级要小。 ​ 最终，设置 image view 的 mode 为 Aspect Fit。这个设置，让 image view 强制调整图片大小，以符合 image view 的边界，同时保持图片的比例。这让 stack view 可以任意调整 image view ，而不会扭曲图像。 ​ 想要了解关于 “固定一个视图来填充它的父视图” 的更多信息，查看 Attributes 和 Adaptive Single View 。 嵌套的 Stack View​ 这节展示了一个复杂的布局，这个布局是用多个嵌套的 stack views 创建的。然而，在这个例子里，stack views 不能独自创建想要的行为。相反，需要额外的约束来改善布局。 ​ 在视图层级建立后，添加下一小段展示的约束，视图和约束 。 视图和约束 ​ 当和嵌套的 stack views 打交道时，从里到外的方式是最简单的。首先在 Interface Builder 中列出展示名字的三行。把每一行的 Label 和 text field 放在它们正确的相对位置上，选中他俩，然后点击 Editor &gt; Embed In &gt; Stack View 菜单选项。这个为这一行创建一个水平的 stack view 。 ​ 接着，水平定位这些行，选择它们，再点击 Editor &gt; Embed In &gt; Stack View 菜单选项。这为这些行创建一个水平的 stack 。按照下图所示，继续建立约束。 Root Stack View.Leading = Superview.LeadingMargin Root Stack View.Trailing = Superview.TrailingMargin Root Stack View.Top = Top Layout Guide.Bottom + 20.0 Bottom Layout Guide.Top = Root Stack View.Bottom + 20.0 Image View.Height = Image View.Width First Name Text Field.Width = Middle Name Text Field.Width First Name Text Field.Width = Last Name Text Field.Width 属性 ​ 每一个 stack 都有自己的一些属性。这些属性定义了 stack 如何布局它的内容。在属性检查器中，设置以下属性： Stack Axis Alignment Distribution Spacing First Name Horizontal First Baseline Fill 8 Middle Name Horizontal First Baseline Fill 8 Last Name Horizontal First Baseline Fill 8 Name Rows Vertical Fill Fill 8 Upper Horizontal Fill Fill 8 Button Horizontal First Baseline Fill Equally 8 Root Vertical Fill Fill 8 ​ 另外，给 text view 一个浅灰色的背景颜色。这样可以更容易地观察 text view 如何调整大小（设备方向改变时）。 View Attribute Value Text View Background Light Gray Color ​ 最后，CHCR 优先级 定义了哪个视图应该为了填充空的空间而拉伸。在尺寸检查器里，设置以下 CHCR 优先级： Name Horizontal hugging Vertical hugging Horizontal resistance Vertical resistance Image View 250 250 48 48 Text View 250 249 250 250 First, Middle, and Last Name Labels 251 251 750 750 First, Middle, and Last Name Text Fields 48 250 749 750 讨论 ​ 在这一小节里，多个 stack views 一起管理大部分的布局。然而，单靠这些 stack views 自己，它们并不能创建所有我们想要的行为。比如，image 大小调整时，应该维持它的比例。不幸的是，在 2.1.1 简单 Stack View 学到的技术在这里并不好使。布局需要接近 image 的 trailing edge 和 bottom edge ，image 使用 Aspect Fit mode 将为其中一个维度增加额外的空白。幸运的是，在这个例子中，图片的宽高比总是正方形，所以你可能让图片完完全全地填充在 image view 的 bounds里，并约束 image view 长宽比为 1:1。 NOTE 在 Interface Builder 中，高宽比约束就是一个视图高、宽之间的简单的约束。Interface Builder 也可以以好几种方式展示约束的 multiplier 。通常，对于高宽比约束，它显示为一个比率。所以，一个视图的宽度与高度相等的约束可能以 1:1 的比率出现。 ​ 另外，所有的 text fields 应该等宽。不行的是，它们分别在不同的 stack view 里，所以 stack view 管不了这个。相反，你可以明确地添加等宽的约束。 ​ 像简单的 stack view ，你也必须修改一些 CHCR 优先级。这些定义了，随着父类的 bounds 的改变，视图是如何压缩和变大的。 ​ 垂直方向上，我们想让 text view 展开，来填充上部 stack 和 button stack之间的空间。因此， text view 的垂直方向上的 content-hugging 优先级要比其他的要小。 ​ 水平方向上，labels 应该以它们的固有内容大小出现，而 text fields 调整大小来填充额外的空间。Labels 用默认的 CHCR 优先级就好使。Interface Builder 已经设置了 content-hugging 优先级为 251，比 text fields 的稍微高一点。然而，你仍然需要降低 text fields 在水平方向上，content-hugging 和 compression resistance 的值。 ​ Image View 应该压缩，这样的话，才能和包含了三行 name 的 name rows stack 保持一样的高度值。然而，stack view 只是稍微松一点拥抱他们的内容。这就意味着，image view 的垂直方向上的 compression resistance 必须非常低，所以 image view 压缩而不是让 stack view 扩展。另外， image view 的高宽比约束会让布局变得复杂，因为这个就意味着垂直和水平的约束可以交互了。这意味着，text fields 的水平方向上的 content-hugging 优先级得是非常低，否则它们将阻止 image view 的收缩。在这两种情况下，设置值为 48 或者更低的优先级。 动态 Stack View​ 这一小节示范了如何在运行时，动态地从 stack 中添加、移除项。对 stack 的所有的改变都是动画形式的。另外，例子中 stack view 是放在一个滚动视图里的，如果列表太长而无法完全显示在屏幕上的时候，让你可以滚动浏览列表。 NOTE 这一小节只打算示范一下动态地使用 stack view ，使用滚动视图里的 stack view。在真实的App里，这一小节的行为应该使用 UITableView 类来实现。一般，你不应该使用动态 stack view 来简单地从零开始实现一个 TableView 的克隆。相反，使用它们创建那种“不能轻松使用其他技术完成的”动态用户界面。 视图与约束 ​ 最初的用户界面比较简单。在你的场景里面放一个滚动视图，然后调整大小来填满屏幕。然后，把一个 stack view 放到这个滚动视图中去，然后在 stack view 中放置 “Add item”按钮。所有东西放好后，设置以下约束： Scroll View.Leading = Superview.LeadingMargin Scroll View.Trailing = Superview.TrailingMargin Scroll View.Top = Superview.TopMargin Bottom Layout Guide.Top = Scroll View.Bottom + 20.0 Stack View.Leading = Scroll View.Leading Stack View.Trailing = Scroll View.Trailing Stack View.Top = Scroll View.Top Stack View.Bottom = Scroll View.Bottom Stack View.Width = Scroll View.Width 属性 在属性检查器中，设置 stack view 的属性： Stack Axis Alignment Distribution Spacing Stack View Vertical Fill Equal Spacing 0 代码 这一小节需要一点代码，来在 stack view 中添加项、移除项。创建一个自定义视图控制器，设置 滚动视图的 outlet 和 stack 的 outlet。 1234567class DynamicStackViewController: UIViewController &#123; @IBOutlet weak private var scrollView: UIScrollView! @IBOutlet weak private var stackView: UIStackView! // Method implementations will go here...&#125; 接着，重载 viewDidLoad 方法，来设置滚动视图的初始位置。你想让滚动视图的内容从状态栏的下方开始。 12345678override func viewDidLoad() &#123; super.viewDidLoad() // setup scrollview let insets = UIEdgeInsetsMake(20.0, 0.0, 0.0, 0.0) scrollView.contentInset = insets scrollView.scrollIndicatorInsets = insets&#125; 现在，为 “Add item” 按钮添加 action 方法。 12345678910111213141516171819@IBAction func addEntry(sender: AnyObject) &#123; let stack = stackView let index = stack.arrangedSubviews.count - 1 let addView = stack.arrangedSubviews[index] let scroll = scrollView let offset = CGPoint(x: scroll.contentOffset.x, y: scroll.contentOffset.y + addView.frame.size.height) let newView = createEntry() newView.hidden = true stack.insertArrangedSubview(newView, atIndex: index) UIView.animateWithDuration(0.25) &#123; () -&gt; Void in newView.hidden = false scroll.contentOffset = offset &#125;&#125; 这个方法，为滚动式图计算出一个新的偏移量，然后创建一个新的条目视图。条目视图是隐藏的，添加到 stack 中。隐藏的视图并不影响 看起来的样子或是 stack 的布局，所以 stack 的样子保持不变。然后，在一个动画 block 中，视图被显示，滚动偏移量被更新，视图的样子动态呈现。 添加一个相似的方法来删除条目视图；然而，不像 addEntry 方法，这个方法不与 Interface Builder 中的任何控件有关联。相反，App会以编程方式将每个条目视图链接到这个方法。 123456789func deleteStackView(sender: UIButton) &#123; if let view = sender.superview &#123; UIView.animateWithDuration(0.25, animations: &#123; () -&gt; Void in view.hidden = true &#125;, completion: &#123; (success) -&gt; Void in view.removeFromSuperview() &#125;) &#125;&#125; 这个方法在动画 block 中隐藏了视图。在动画完成后，视图会从视图层级中被移除。这会自动从 stack 的排列视图列表中移除这个视图。 尽管条目试图可以是任何视图，这个例子使用的 stack view 包括日期标签，一个随机的十六进制字符串标签，一个删除按钮。 1234567891011121314151617181920212223242526272829303132333435363738private func createEntry() -&gt; UIView &#123; let date = NSDateFormatter.localizedStringFromDate(NSDate(), dateStyle: .ShortStyle, timeStyle: .NoStyle) let number = \"\\(randomHexQuad())-\\(randomHexQuad())-\\(randomHexQuad())-\\(randomHexQuad())\" let stack = UIStackView() stack.axis = .Horizontal stack.alignment = .FirstBaseline stack.distribution = .Fill stack.spacing = 8 let dateLabel = UILabel() dateLabel.text = date dateLabel.font = UIFont.preferredFontForTextStyle(UIFontTextStyleBody) let numberLabel = UILabel() numberLabel.text = number numberLabel.font = UIFont.preferredFontForTextStyle(UIFontTextStyleHeadline) let deleteButton = UIButton(type: .RoundedRect) deleteButton.setTitle(\"Delete\", forState: .Normal) deleteButton.addTarget(self, action: \"deleteStackView:\", forControlEvents: .TouchUpInside) stack.addArrangedSubview(dateLabel) stack.addArrangedSubview(numberLabel) stack.addArrangedSubview(deleteButton) return stack&#125; private func randomHexQuad() -&gt; String &#123; return NSString(format: \"%X%X%X%X\", arc4random() % 16, arc4random() % 16, arc4random() % 16, arc4random() % 16 ) as String&#125;&#125; 讨论 正如这一小节示范的这样，视图可以在运行时被添加或者移除。Stack 的布局会自动调整，来补偿 stack 的排列视图数组的变化。然而，还有几个重要的点值得记住： 隐藏视图仍然在 stack 的排列视图数组中。然而，他们没有显示，不影响其他排列视图的布局。 添加一个视图到 stack 的排列视图数组，会自动添加到视图继承层级。 从 stack 的排列视图数组中移除一个视图，并不会自动的将它从视图层级移除。但是，从视图层级移除一个试图，会自动的在 stack 的排列视图中移除。 在 iOS 中，视图的 hidden 属性一般不是可动画的。但是，只要把视图放到 stack 的排列视图数组中，这个属性会变得可动画了。真正的动画由 stack 管理，而不是视图。所以我们可以使用 hidden 属性来 “动画地” 从 stack 里添加或者移除视图。 这一小节也介绍了通过滚动视图使用 Auto Layout。stack 和 滚动视图之间的约束设置了滚动式图内容区域的大小。 一个等宽的约束明确的设置 stack （还有内容大小）来水平地填满滚动视图。垂直方向上，内容大小基于 stack 的 fitting size 。随着用户添加更多的条目，stack view 就会更长。如果太多内容填满屏幕的话，便自动可以滚动。 想要了解更多，查看 Working with Scroll Views 。 简单约束接下来这一节演示了使用相对简单的约束来创建比较普遍的行为。用这些例子作为基石，去创建更大更复杂的布局吧。 ​ 想要查看这些小节的源代码，查看 Auto Layout Cookbook 工程。 简单单一视图​ 这一小节，定位了一个简单的红色视图，这个红色视图用四周固定的边距填满了父视图。 视图与约束 ​ 在 Interface Builder中，往场景里拖拽一个视图，调整大小来填满场景。使用 Interface Builder 的 guidelines 来选择正确的位置，与父视图边界相关的位置。 NOTE 不用担心非得把视图放在准确的像素点级别的位置上。在设置约束后，系统会计算出正确的大小和位置。 只要视图到位了，设置以下的约束： Red View.Leading = Superview.LeadingMargin Red View.Trailing = Superview.TrailingMargin Red View.Top = Top Layout Guide.Bottom + 20.0 Bottom Layout Guide.Top = Red View.Bottom + 20.0 属性 给视图一个红色的背景颜色，在属性检查器里设置一下的属性： View Attribute Value Red View Background Red 讨论 ​ 这一节的约束让红色视图与父视图的边缘保持一个固定的距离。对于 Leading edge 和 trailing edge 来说，固定你的视图到父视图的边距上（margin）。相反，对于 top 和 bottom ，固定你的视图到 top layout guide 和 bottom layout guide 上。 NOTE 系统自动设置根视图的边距，这样它就会有一个合适的 leading margin 和 trailing margin （16 或者 20 points ，取决于具体的设备），和一个值为 0 的 top margin 与 bottom margin。这让你很容易地让内容出现在控制 bar 的下面（状态栏、导航栏、标签栏、工具栏等）。 然而，这个小节需要把内容放到 bar 下面（如果有的话）。你可以简单地固定红色视图的 leading edge 和 trailing edge 到父视图的 leading margin、trailing margin。但是 top margin 和 bottom margin 必须设置约束到相关的 layout guide。 ​ 默认情况下， Interface Builder 中，一个视图与父视图边缘的标准间隔是 20.0 points。与兄弟视图的间隔是 8.0 points。这个意味着你需要在红色视图顶部和状态栏底部之间使用一个 8 points 的空间。但是，状态栏会在 iPhone 横向时消失，没有状态栏的话，8.0 points 的间距就看起来有点窄了。 ​ 总是选择最适合你 App 的布局。这一小节红色视图的 top 和 bottom 均使用了固定的 20.0 points margin 。这会保持约束的逻辑尽可能的简单，而且在所有的设备方向上都看起来很合理。其他的布局可能用固定 8 points 的 margin 更好。 ​ 如果你想要让你的布局根据 bar 的出现/消失自动调整的话，查看下一小节，可适应的简单视图。 可适应的单视图​ 这一小节，定位了一个简单的蓝色的视图，用四周的 margin 填满父视图。但是，不像上一节那样，这一节的 top margin 基于视图的环境自动调整。如果有状态栏的话，视图会被放在状态栏下边标准间隔（8.0 points）处。如果没有状态栏，视图会被放置在父视图边缘下方 20 points 处。 你可以一起看上一节和这一节的布局。 视图和约束 ​ 在 Interface Builder 中，往场景里面拖拽一个视图，调整它的大小来填满场景，它的边缘都与 guidelines 对齐。然后设置下列约束。 Blue View.Leading = Superview.LeadingMargin Blue View.Trailing = Superview.TrailingMargin Blue View.Top = Top Layout Guide.Bottom + Standard (Priority 750) Blue View.Top &gt;= Superview.Top + 20.0 Bottom Layout Guide.Top = Blue View.Bottom + Standard (Priority 750) Superview.Bottom &gt;= Blue View.Bottom + 20.0 属性 给视图设置一个蓝色的背景颜色，在属性检查器中设置如下属性： View Attribute Value Blue View Background Blue 讨论 ​ 这一小节为蓝色视图的 top 和 bottom 创建了具有适应性边距。如果有 bar，视图的边缘就会放到离 bar 8.0 points 的地方。如果没有 bar，边缘就会被设置在离父视图边缘 20.0 points 处。 ​ 这一小节使用了 layout guides 来纠正视图内容的位置。系统根据任何 bar 的才出现与否与大小来设置这些 guide 的位置。top layout guide 的位置沿着任何 top bar (例如，状态栏和导航栏) 的底部边缘。bottom layout guide 沿着任何 bottom bar （例如，标签栏）的顶部边缘。如果没有 bar ，系统会沿着父视图的相关边缘来定位 layout guide。 ​ 这一节使用了一堆约束来创建这个具有适用性的行为。第一个约束是 required 的，大于等于的约束。这个约束保证蓝色视图的边缘总是离父视图的边缘最少 20 points 。实际上，它定义了一个最小 20 points 的边距。 ​ 接下来，另外一个可选的约束尝试把视图设置的离相关的 layout guide 8 points 远。因为这个约束是可选的，如果系统不能满足这个约束，约束本身还是会尝试尽可能的接近，这时候，约束就表现的像春天般的力量一样，把蓝色视图的边缘拉向它的 layout guide。 ​ 如果系统没有显示 bar，那么 layout guide 就跟父视图的边缘相等。蓝色视图的边缘不能同时离父视图的边缘 8 points 远和 20 points （或者更多）远。因此，系统不能满足这个可选的约束。不过，这个约束还是会尽它所能——设置最小边距为 20 points。 ​ 如果一个 bar 呈现了，这时两个约束都会被满足。所有的 bar 都是至少 20 points 宽。因此，如果系统把蓝色视图的边缘放的离 bar 的边缘 8 points 远，就能保证离父视图的边缘的距离超过 20 points。 ​ 这个技术，使用一对约束，这对约束就像是作用力一样，往相反的方向推，这种技术经常被用来创建具有可适用性的布局。你会再一次见到的，当我们查看 Views with Intrinsic Content Size 中的 content-hugging and compression-resistance (CHCR) 优先级的时候。 两个等宽的视图​ 这一小节布局了两个挨着的视图。这俩视图总是有一样的宽，不管父视图的边界如何变化。这俩视图一起，填满了父视图，每一边都有一个 固定的边距（margin），他俩之间也有一个标准的间隔间距。 视图和约束 ​ 在 Interface Builder 中，拖拽两个视图，然后像图示那样放置，填满场景，使用 guidelines 来设置场景中对象之间的正确间隔。 ​ 这时候，先不要担心让视图等宽。放置一个大概的、相对的位置，让约束来做剩下难的部分。 ​ 视图就位后，设置下列约束。 Yellow View.Leading = Superview.LeadingMargin Green View.Leading = Yellow View.Trailing + Standard Green View.Trailing = Superview.TrailingMargin Yellow View.Top = Top Layout Guide.Bottom + 20.0 Green View.Top = Top Layout Guide.Bottom + 20.0 Bottom Layout Guide.Top = Yellow View.Bottom + 20.0 Bottom Layout Guide.Top = Green View.Bottom + 20.0 Yellow View.Width = Green View.Width 属性 ​ 在属性检查器中设置视图的背景颜色。 View Attribute Value Yellow View Background Yellow Green View Background Green 讨论 ​ 这个布局明确的定义了两个视图的 top margin 和 bottom margin。只要这些边距（margin）一样，视图就会隐式地等高。但是，这个不是这个布局唯一的解决办法。与其把绿色视图的 top 和 bottom 固定到父视图，不如让它们和黄色视图的 top 和 bottom 相等。明确地将视图的 top edge 和 bottom edge 对齐，就会生成一样的垂直布局。 ​ 尽管一个像这个一样相对简单的布局，可是用一些不同的约束创建出来。每种方法都有优点和缺点。这一小节的方法有两个主要的优点。第一（也是最重要的一点），容易理解。第二，如果你移除其中一个视图，布局会保持大部分完好无损。 ​ 在视图层级中移除视图也会移除那个视图所有的约束。这意味着如果你移除了黄色视图，约束1、2、4、6、8会被移除。然而，仍然有3个约束条件保持绿色视图的位置。你只需要添加一个约束，用来定义绿色视图的 leading edge ，布局就修好了。 ​ 最主要的缺点就是你需要手动地保证所有的 top 约束和所有的 bottom 约束是相等的。修改它们之中一个常量，视图就会变得十分不整齐。在实际运用中，设置一样的常量这件事，如果你使用 Interface Builder 中的 Pin 工具来创建约束，就会很容易。但是如果你想通过拖拽来创建常量一样的约束，就难多了。 ​ 当面对多个、同样有效的约束集的时候，应该跟我我们布局的环境，选择最容易理解、最容易维护的那个约束集。例如，如果居中对齐一些大小不一样的视图，约束它们的 center X 属性可能是最简单的方法。但是对于其他的布局需求，可能使用视图变换、或者高、宽变成了最简单的方法。 ​ 想要了解更多关于为你的布局选择最佳的约束集的信息，查看 1.3.4 创建清晰的、可以满足的布局 。 两个不一样宽的视图​ 这一小节跟 2.2.3 两个等宽的视图 很类似，有一个比较大的不同。在这一小节，橙色视图总是紫色视图的两倍宽。 视图与约束 ​ 像之前一样，拖拽出两个视图，把他们放在大概正确的位置，然后设置以下约束。 Purple View.Leading = Superview.LeadingMargin Orange View.Leading = Purple View.Trailing + Standard Orange View.Trailing = Superview.TrailingMargin Purple View.Top = Top Layout Guide.Bottom + 20.0 Orange View.Top = Top Layout Guide.Bottom + 20.0 Bottom Layout Guide.Top = Purple View.Bottom + 20.0 Bottom Layout Guide.Top = Orange View.Bottom + 20.0 Orange View.Width = 2.0 x Purple View.Width 属性 ​ 在属性检查器中设置视图的背景颜色。 View Attribute Value Purple View Background Purple Orange View Background Orange 讨论 ​ 这一小节在宽的约束上使用了乘数（multiplier）。Multiplier 只能被用在视图高、宽的约束上（不能用在位置上）。让你可以设置两个不同视图的相关大小。或者，您可以在视图自身的高度和宽度之间设置一个约束，指定视图的高宽比。 ​ Interface Builder 让你可以用好几种格式确定乘数。你可以写数字（如2.0），写百分比（200%），写分数（2/1），写比例（2：1）。 有复杂宽度的两个视图​ 这一节跟 2.2.4 两个不一样宽的视图 几乎一样。但是，在这，你要使用一对约束来定义一个更加复杂的视图宽度。在这一小节，系统尝试让红色视图是蓝色视图的两倍宽，但是蓝色视图至少要是 150 points 宽。所以，在iPhone 竖屏的情况下，两个视图几乎是等宽的，在横向方向下，两个视图都变大了，但是红色视图这时候是蓝色视图的两倍宽了。 视图与约束 ​ 在画布上放置这俩视图，然后设置如下的约束。 Blue View.Leading = Superview.LeadingMargin Red View.Leading = Blue View.Trailing + Standard Red View.Trailing = Superview.TrailingMargin Blue View.Top = Top Layout Guide.Bottom + 20.0 Red View.Top = Top Layout Guide.Bottom + 20.0 Bottom Layout Guide.Top = Blue View.Bottom + 20.0 Bottom Layout Guide.Top = Red View.Bottom + 20.0 Red View.Width = 2.0 x Blue View.Width (Priority 750) Blue View.Width &gt;= 150.0 属性 ​ 在属性检查其中设置视图的背景颜色。 View Attribute Value Blue View Background Blue Red View Background Red 讨论 ​ 这一小节用了一对约束来控制视图的宽。那个可选的、等比例的宽度的约束拉着视图，以实现红色视图是蓝色视图的两倍宽。但是，那个 required 大于等于的约束定义了蓝色视图宽度的最小值，是个常量。 ​ 实际上，如果父视图的 leading margin 和 trailing margin 之间的距离是 458.0 points 或者更大（150.0+300.0+8.0），那么红色视图就是蓝色视图的两倍大。如果父视图的 leading margin 和 trailing margin 之间的距离比较小的话，那么蓝色视图的宽就会设置成 150.0 ，此时红色视图就会填满余下的空间（视图之间有 8.0 points 的间隔）。 ​ 你也许意识到了这是 2.2.2 可适应的单视图 中引入的模式的另一种变体。 ​ 你可以通过添加额外的约束展开这个设计——比如，通过使用三个约束。一个 required 的约束设置红色视图的最小宽度，一个高优先级的可选的约束来设置蓝色视图的最小宽度，一个低优先级的可选的约束来设置这俩视图的首选大小比例。 有固有内容大小的视图​ 接下来这些小节们，示范了如何使用具有固有内容大小的视图。一般，固有内容大小会简化布局，因为我们需要的约束就会减少。然而，使用固有内容大小经常需要设置视图的 content-hugging 和 compression-resistance（CHCR）优先级，这会增加额外的复杂度。 ​ 想要查看这些小节的源代码，查看 Auto Layout Cookbook 工程。 简单的 Label 和 Text Field​ 这一小节，示范了布局一个简单的 label 和 text field 。在这个例子中，label 的宽度基于文本属性的大小，text field 会扩展或者压缩来适应剩余的空间。 ​ 因为这一小节会使用视图的 固有内容大小，我们只需要五个约束来唯一地确定我们的布局。然而，你得确保设置正确了 CHCR 优先级，才能正确的自动调整大小。 ​ 想要了解更多信息关于 固有内容大小和 CHCR 优先级，查看 1.3.7 固有内容尺寸大小 。 视图与约束 ​ 在 Interface Builder，拖拽一个 label 和一个 text field 。设置 label 的文本和 text field 的占位符，然后设置如下的约束。 Name Label.Leading = Superview.LeadingMargin Name Text Field.Trailing = Superview.TrailingMargin Name Text Field.Leading = Name Label.Trailing + Standard Name Text Field.Top = Top Layout Guide.Bottom + 20.0 Name label.Baseline = Name Text Field.Baseline 属性 ​ 为了让 text field 可以拉伸来填充可用的空间，它的 content-hugging 必须比 label 的低。默认情况下， Interface Builder 应该设置 label 的 content-hugging 为 251，text field 的为250。你可以在尺寸检查器中确认一下。 Name Horizontal hugging Vertical hugging Horizontal resistance Vertical resistance Name Label 251 251 750 750 Name Text Field 250 250 750 750 讨论 ​ 注意，这个布局只用了两个约束（4和5）来定义垂直方向上的布局，只用了三个约束（1、2、3）定义了水平方向上的布局。1.3.4 创建清晰的、可以满足的布局 里面的经验法则表明，我们每个视图需要水平方向上两个约束、垂直方向上两个约束；但是，label 和 text field 的固有内容大小提供了它们的高和 label 的宽，去掉了原本所需要的 3 个布局。 ​ 这个布局假设了 text feild 的高度大于 label 的高度，而且使用 text field 的噶度来定义和 top layout guide 之间的距离。因为，labe 和 text field 都是用来展示文本的，本小节使用文本的 baseline 来对齐它们。 ​ 水平方向上，你仍然需要确定哪个视图扩展自己来填充可用空间。我们通过修改视图的 CHCR 优先级来确定这个。比如，Interface Builder 已经设置了 name label的水平、垂直 content-hugging 优先级为 251。因为这个比 text field 的 250 大，所以 text field 拉伸自己来填充额外的空间。 NOTE ​ 如果如果布局要在一个对于控件来说太小的地方显示，我们也需要修改视图的 compression resistance 的值。这个 compression resistance 值定义了当没有足够的空间的时候，哪个视图应该被缩短。 ​ 在本例子中，修改 compression resistance 留给读者自己联系。如果 name label 的文本或者字体足够大，然而，却没有足够的空间，就会产生一个有歧义、模糊的布局。系统会选择一个约束来打破，要么 text field 被缩短，要么 label 被缩短。 ​ 理想状态下，如果必要时有可能使用紧缩型的 size class 的话，我们肯定会想创建出一个额外空间永远不要太大的布局。然而，当我们设计的视图支持多语言或者动态文本的话，很难预测你的一行会有多大。为防止意外情况，修改 compression resistance 为一个安全一点的值。 Label 和 Text Field 的动态高度​ 2.3.1 简单的 Label 和 Text Field 通过假设 text field 永远比 label 高，简化了布局。然而，并不总是那样的情况。如果我们增加了 label 字体的大小到足够大，就会比 text field 高。 ​ 这一小节基于运行时最高的控件，动态地设置了垂直方向上控件们的空间。如果是系统的 regular font 的话，这一小节就会跟 2.3.1 简单的 Label 和 Text Field 一样了（看下图）。然而，如果你增加了 label 的字体大小到 36.0 points ，然后布局的垂直空间就会从 label 的 top 开始计算。 ​ 这个情况有点作。毕竟，如果你增加了 label 的字体大小，你一般也会增加 text field 字体的大小。然而，如果通过 IPhone 的 accessibility setting 给了一个额外、额外、额外大的字体，当出现了 动态文本于固定大小控件（如图片）组合的情况，这个技术就会很有用。 视图和约束 ​ 像 2.3.1 简单的 Label 和 Text Field 一样设置我们的视图，但是约束更加复杂一些，如下。 Name Label.Leading = Superview.LeadingMargin Name Text Field.Trailing = Superview.TrailingMargin Name Text Field.Leading = Name Label.Trailing + Standard Name Label.Top &gt;= Top Layout Guide.Bottom + 20.0 Name Label.Top = Top Layout Guide.Bottom + 20.0 (Priority 249) Name Text Field.Top &gt;= Top Layout Guide.Bottom + 20.0 Name Text Field.Top = Top Layout Guide.Bottom + 20.0 (Priority 249) Name label.Baseline = Name Text Field.Baseline 属性 ​ 为了让 text field 可以拉伸来填充可用的空间，它的 content-hugging 必须比 label 的低。默认情况下， Interface Builder 应该设置 label 的 content-hugging 为 251，text field 的为250。你可以在尺寸检查器中确认一下。 Name Horizontal hugging Vertical hugging Horizontal resistance Vertical resistance Name Label 251 251 750 750 Name Text Field 250 250 750 750 讨论 ​ 这一小节，使用了每个控件一对约束。一个 required、大于等于约束定义了控件和 layout guide 之间的最小距离，另外一个是 optional 约束，这个约束会尽量拉得控件离 layout guide 正好 20.0 points 。 ​ 对于高点的控件，两个约束都能满足，所以系统会把它放在离 layout guide 正好 20.0 points 的地方。但是，对于低点的控件来说，只有最小距离是满足的。另外一个约束被忽视了。这就使得 ，随着控件的高度在运行时的变化，Auto Layout 系统可以动态的重计算。 NOTE 确保设置了可选约束的优先级比默认的 content-hugging（250） 低。否则，系统会打破 content-hugging 约束进而拉伸视图，而不是重新调整它的位置。 当使用 baseline 对齐的布局时，这可能会特别令人困惑，因为 baseline 对齐只有在 text view 处于 固有内容高度的时候，才有效。如果系统调整了其中一个视图的大小，尽管有必要的 baseline 约束，但文本可能不会正确地对齐。 固定高度的栏​ 这一小节扩展了 2.3.1 简单的 Label 和 Text Field ，变成了一栏一栏的 label 和 text field 。所有 label 的 trailing edge 是对齐的。text field 们的 leading edge 和 trailing edge 是对齐的，所处的水平位置基于最长的 label 确定。像 2.3.1 那节一样，这一小节也嘉定 text fields 总是比 label 高。 视图与约束 ​ 布局你的 label 们和 text field 们，然后设置如下的约束。 First Name Label.Leading = Superview.LeadingMargin Middle Name Label.Leading = Superview.LeadingMargin Last Name Label.Leading = Superview.LeadingMargin First Name Text Field.Leading = First Name Label.Trailing + Standard Middle Name Text Field.Leading = Middle Name Label.Trailing + Standard Last Name Text Field.Leading = Last Name Label.Trailing + Standard First Name Text Field.Trailing = Superview.TrailingMargin Middle Name Text Field.Trailing = Superview.TrailingMargin Last Name Text Field.Trailing = Superview.TrailingMargin First Name Label.Baseline = First Name Text Field.Baseline Middle Name Label.Baseline = Middle Name Text Field.Baseline Last Name Label.Baseline = Last Name Text Field.Baseline First Name Text Field.Width = Middle Name Text Field.Width First Name Text Field.Width = Last Name Text Field.Width First Name Text Field.Top = Top Layout Guide.Bottom + 20.0 Middle Name Text Field.Top = First Name Text Field.Bottom + Standard Last Name Text Field.Top = Middle Name Text Field.Bottom + Standard 属性 ​ 在属性检查器里，设置如下属性。特别的，让左右 label 的文本右对齐。这能让我们使用比自身文本内容大的 label ，但是还能在 text fields 的旁边边缘对齐。 View Attribute Value First Name Label Text First Name First Name Label Alignment Right First Name Text Field Placeholder Enter first name Middle Name Label Text Middle Name Middle Name Label Alignment Right Middle Name Text Field Placeholder Enter middle name Last Name Label Text Last Name Last Name Label Alignment Right Last Name Text Field Placeholder Enter last name 对每一对来说，label 的 content-hugging 都应该比 text field 的高。而且，Interface Builder 自动给你做这个。但是，你可以在尺寸检查器中验证以下的优先级。 Name Horizontal hugging Vertical hugging Horizontal resistance Vertical resistance First Name Label 251 251 750 750 First Name Text Field 250 250 750 750 Middle Name Label 251 251 750 750 Middle Name Text Field 250 250 750 750 Last Name Label 251 251 750 750 Last Name Text Field 250 250 750 750 讨论 ​ 这一小节就好像是从拷贝了 2.3.1 简单的 Label 和 Text Field 中的布局，一个摞一个。但是没我们还是得添加一些额外的约束让他们排列好。 ​ 首先，通过右对齐所有 label 的文本，简化了我们的问题。你可以让所有的 label 等宽，不管文本的长度，很容易地就把他们的 trailing edge 对齐了。另外，因为一个 label 的 compression resistance 比它的 content-hugging 大，所以所有的 label 都更倾向于被拉伸，而不是被挤压。对齐 leading edge 和 trailing edge ，所有 label 就会自然地拉伸，拉伸到最长 label 的固有内容大小。 ​ 因此，你只需要对齐所有 label 的 leading edge 和 trailing edge 。你也需要对齐所有 text field 的 leading edge 和 trailing edge 。幸运的事，所有 label 的 leading edge 已经和父视图的 leading margin 对齐了。相似地，所有 text field 的 trailing edge 都和父视图的 trailing margin 对齐。你只需要让另外两个的 leading edge、trailing edge 也这样。加上所有的行都是等宽的，所有东西都对齐了。 ​ 我们有好几种方式达到这种效果。对于这一小节，是让所有的 text field 等宽。 动态高度的栏​ 这一小节把 2.3.2 Label 和 Text Field 的动态高度 和 2.3.3 固定高度的栏 的内容结合到了一起。这一小节的目标包括： 基于最长的那个 label 的长度，把所有的 label 的 trailing edge 对齐。 text field 等宽，他们的 leading edge 和 trailing edge 均对齐。 text field 扩展自己来填充父视图中剩余的空间。 行与行之间的高度，基于行内最高的元素的高度。 所有的东西都是动态的，所以字体大小和文本修改时，布局会更新。 视图与约束 ​ 与 2.3.3 固定高度的栏 中一样布局你的 label 和 text field。但是，你需要额外的约束。 First Name Label.Leading = Superview.LeadingMargin Middle Name Label.Leading = Superview.LeadingMargin Last Name Label.Leading = Superview.LeadingMargin First Name Text Field.Leading = First Name Label.Trailing + Standard Middle Name Text Field.Leading = Middle Name Label.Trailing + Standard Last Name Text Field.Leading = Last Name Label.Trailing + Standard First Name Text Field.Trailing = Superview.TrailingMargin Middle Name Text Field.Trailing = Superview.TrailingMargin Last Name Text Field.Trailing = Superview.TrailingMargin First Name Label.Baseline = First Name Text Field.Baseline Middle Name Label.Baseline = Middle Name Text Field.Baseline Last Name Label.Baseline = Last Name Text Field.Baseline First Name Text Field.Width = Middle Name Text Field.Width First Name Text Field.Width = Last Name Text Field.Width First Name Label.Top &gt;= Top Layout Guide.Bottom + 20.0 First Name Label.Top = Top Layout Guide.Bottom + 20.0 (Priority 249) First Name Text Field.Top &gt;= Top Layout Guide.Bottom + 20.0 First Name Text Field.Top = Top Layout Guide.Bottom + 20.0 (Priority 249) Middle Name Label.Top &gt;= First Name Label.Bottom + Standard Middle Name Label.Top = First Name Label.Bottom + Standard (Priority 249) Middle Name Text Field.Top &gt;= First Name Text Field.Bottom + Standard Middle Name Text Field.Top = First Name Text Field.Bottom + Standard (Priority 249) Last Name Label.Top &gt;= Middle Name Label.Bottom + Standard Last Name Label.Top = Middle Name Label.Bottom + Standard (Priority 249) Last Name Text Field.Top &gt;= Middle Name Text Field.Bottom + Standard Last Name Text Field.Top = Middle Name Text Field.Bottom + Standard (Priority 249) 属性 ​ 在属性检查器中，设置如下属性。特别的，所有 label 的文本右对齐。右对齐 label 让你可以使用比自身文本长的 label，文本的边缘挨着 text field 右对齐。 View Attribute Value First Name Label Text First Name First Name Label Alignment Right First Name Text Field Placeholder Enter first name Middle Name Label Text Middle Name Middle Name Label Alignment Right Middle Name Text Field Placeholder Enter middle name Last Name Label Text Last Name Last Name Label Alignment Right Last Name Text Field Placeholder Enter last name 对每一对来说，label 的 content-hugging 都应该比 text field 的高。而且，Interface Builder 自动给你做这个。但是，你可以在尺寸检查器中验证以下的优先级。 Name Horizontal hugging Vertical hugging Horizontal resistance Vertical resistance First Name Label 251 251 750 750 First Name Text Field 250 250 750 750 Middle Name Label 251 251 750 750 Middle Name Text Field 250 250 750 750 Last Name Label 251 251 750 750 Last Name Text Field 250 250 750 750 讨论 ​ 这一小节把 2.3.2 Label 和 Text Field 的动态高度 和 2.3.3 固定高度的栏 用到的技术结合了一下。像 2.3.2 动态高度 这一节一样，本节使用了约束对来动态设置行与行之间的垂直间隔。像 2.3.3 固定高度的栏 这一节一样，本节右对齐所有 label 的文本，明确等宽的约束来在垂直方向上排列整齐。 NOTE 本例子的视图与 layout guide 之间使用了 20.0 points 的间隔，兄弟视图之间 8.0 points 的间隔。这有设置一个固定的 20 points 的 top margin 的效果。如果随着 bar 的出现/隐藏，想动态地调整 margin ，你需要添加额外的约束，所使用到的技术在 2.2.1 简单单一视图 中有描述。但是具体的实现让读者挑战一下。 ​ 正如你看到的，布局的逻辑开始变得有点复杂了，但是，还是有几种方法让我们可以简化一下的，首先，像之前提到的那样，你应该尽可能的使用 stack view。另外，你可以给控件编组（相同组织若干控件的情况），然后一组一组的布局，这使得我们把一个单一的复杂的布局打散成一个更小、但是更容易管理的模块。 两个等宽的按钮​ 这一小节示范了如何布局两个等宽的按钮。垂直方向上，按钮跟屏幕的 bottom 对齐。水平方向上，它俩都拉伸，这样才能填充所有的可用空间。 视图与约束 ​ 在 Interface Builder 中，往场景中拉两个按钮。使用 guideline 把它们沿着场景的 bottom 对齐。不用担心两个按钮是不是等宽，我们可以先拉伸其中的一个填充余下的水平空间。大概地把它俩放到大概的位置，然后设置下面的约束。Auto Layout 会正确地计算出它们的最终位置。 Short Button.Leading = Superview.LeadingMargin Long Button.Leading = Short Button.Trailing + Standard Long Button.Trailing = Superview.TrailingMargin Bottom Layout Guide.Top = Short Button.Bottom + 20.0 Bottom Layout Guide.Top = Long Button.Botton + 20.0 Short Button.Width = Long Button.Width 属性 ​ 给 button 一个看得见的背景颜色，这样当设备旋转的时候我们可以更容易的看出它们 frame 的。另外，button 们使用不一样的标题，这么做是为了显示 button 标题并不影响 button 的宽。 View Attribute Value Short Button Background Light Gray Color Short Button Title short Long Button Background Light Gray Color Long Button Title Much Longer Button Title 讨论 ​ 这一小节使用 button 的固有高度，但是计算布局的时候不使用它们的固有宽度。水平方向上，the buttons are explicitly sized so that they have an equal width and fill the available space。想了解按钮的固有高度是如何影响布局的，查看 。在本小节，垂直方向上只有两个约束，而不是四个。 ​ 不同按钮还设定了不同的文本内容，这帮助阐述了按钮的文本是如何影响（这一小节，是不影响）布局的。 NOTE 对于这一小节来说，按钮都设置了浅灰色的背景颜色，方便我们看到它们的 frame。一般，如果按钮和标签有透明的背景，察觉 frame 的改变就会很难（如果不是不可能的话）。 三个等宽的按钮​ 这一张拓展了 2.3.5 两个等宽的按钮 ，使用了三个等宽的按钮。 视图与约束 ​ 布局按钮，并设置如下约束。 Short Button.Leading = Superview.LeadingMargin Medium Button.Leading = Short Button.Trailing + Standard Long Button.Leading = Medium Button.Trailing + Standard Long Button.Trailing = Superview.TrailingMargin Bottom Layout Guide.Top = Short Button.Bottom + 20.0 Bottom Layout Guide.Top = Medium Button.Bottom + 20.0 Bottom Layout Guide.Top = Long Button.Bottom + 20.0 Short Button.Width = Medium Button.Width Short Button.Width = Long Button.Width 属性 ​ 给 button 一个看得见的背景颜色，这样当设备旋转的时候我们可以更容易的看出它们 frame 的。另外，button 们使用不一样的标题，这么做是为了显示 button 标题并不影响 button 的宽。 Para View Attribute Value Short Button Background Light Gray Color Short Button Title Short Medium Button Background Light Gray Color Medium Button Title Medium Long Button Background Light Gray Color Long Button Title Long Button Title 讨论 ​ 添加一个额外的 button 需要添加额外的 3 个约束（两个水平约束和一个垂直约束）。请记住，我们并不适用 button 的固有宽度，所以你需要至少分别两个水平约束来确定它们俩的位置与大小。但是，我们使用了 button 的固有高度，所以我们只需要一个额外的约束就可以确定垂直方向上的位置。 NOTE 想要非常快的设置等宽的约束，全选三个按钮，使用 Interface Builder 的 Pin 工具来创建一个等宽的约束。Interface Builder 自动创建俩 required 的约束。 两个具有相等间隔的按钮​ 外表上来看，这一小节很像 2.3.5 两个等宽的按钮 （图片上很像）。但是，在这一小节，button 的宽几与最长的文本。如果没有足够的空间了，button 就会被拉伸直到拉伸到较长按钮的固有内容大小值。俩按钮周围的任何额外的空间都被均等的划分。 ​ 在 iPhone 上，手机处于竖屏时， 2.3.5 两个等宽的按钮 和 2.3.7 两个具有相等间隔的按钮 看起来一样。横屏是，差异才明显（或者使用一个较大的设备，比如 iPad）。 视图与约束 ​ 在 Interface Builder 中，拖拽出两个 button 和三个 view 对象，两个 button 放在三个 view 中间，然后设置如下的约束。 Leading Dummy View.Leading = Superview.LeadingMargin Short Button.Leading = Leading Dummy View.Trailing Center Dummy View.Leading = Short Button.Trailing Long Button.Leading = Center Dummy View.Trailing Trailing Dummy View.Leading = Long Button.Trailing Trailing Dummy View.Trailing = Superview.TrailingMargin Bottom Layout Guide.Top = Leading Dummy View.Bottom + 20.0 Bottom Layout Guide.Top = Short Button.Bottom + 20.0 Bottom Layout Guide.Top = Center Dummy View.Bottom + 20.0 Bottom Layout Guide.Top = Long Button.Bottom + 20.0 Bottom Layout Guide.Top = Trailing Dummy View.Bottom + 20.0 Short Button.Leading &gt;= Superview.LeadingMargin Long Button.Leading &gt;= Short Button.Trailing + Standard Superview.TrailingMargin &gt;= Long Button.Trailing Leading Dummy View.Width = Center Dummy View.Width Leading Dummy View.Width = Trailing Dummy View.Width Short Button.Width = Long Button.Width Leading Dummy View.Height = 0.0 Center Dummy View.Height = 0.0 Trailing Dummy View.Height = 0.0 属性 ​ 给 button 一个看得见的背景颜色，这样当设备旋转的时候我们可以更容易的看出它们 frame 的。另外，button 们使用不一样的标题。这些 button 的大小应该基于应该基于最长的 title。 View Attribute Value Short Button Background Light Gray Color Short Button Title Short Long Button Background Light Gray Color Long Button Title Much Longer Button Title 讨论 ​ 正如我们看到的，约束变复杂了。尽管这个例子是想阐述一种特定的技术，在真正的开发是，还是建议大家使用 stack view 代替。 ​ 在这个例子中，我们想让白色空间的大小随着父视图的 frame 的改变而改变。这就意味着你需要很多等宽约束来控制白色空间的宽；但是，你不能为空的空间创建约束。必须得是一个对象，你才能约束它的大小。 ​ 在这一小节，我们使用“假”的 view 来代表空的空间。这些 view 是空的 UIView 实例。在这一小节，它们被设置了 0 point 的高度，一次来最小化它们对视图层级的影响。 NOTE “假” view 能给你的布局带来不小的成本，一定要谨慎使用。如果这些 views 很大，它们的绘图上下文会消耗大量的内存，就算不包括任何有用的信息。 另外，这些 views 参与到视图层级的响应者链中。这就意味着它们能响应那些沿着响应者链条发送的消息，比如 hit testing 。如果不小心处理的话，这些 views 可能会介入、响应这些消息，会导致难以定位的 bug。 ​ 另一种方法，你可以使用 UILayoutGuide 的实例来代表白色空间。这个轻量级的类代表了一个能参与到 Auto Layout 约束中去的矩形 frame 。Layout guides 没有绘图上下文环境，而且它们不是视图层级的一部分。这使得 layout guide 很理想的胜任编组、定义白色空间等工作。 ​ 不幸运的是，我们不能在 Interface Builder 中添加一个 layout guide ，而编程与故事板的混合也会变得非常复杂。一般的经验法则是，使用故事板和 Interface Builder，比使用自定义的 layout guide 要好。 ​ 这一小节使用了大于等于的约束关系来设置 button 之间的最小间隔。 Required 约束也保证了 button 总是等宽的，“假“ view 也是等宽的（但是可能跟 button 的宽不同）。余下的布局大部分都是靠 button 的 CHCR 优先级来管理的。如果没有足够的空间了，”假“ views 折起来折到 0 point 的宽度，buttons 均分它们之间的可用空间（它们之间用一个标准的间隔）。随着可用空间的增加，button 会扩展直到达到了较大 button 的固有宽度，然后”假“视图开始扩展。”假“视图会继续扩展来填充余下的空间。 2.3.8 两个基于 Size Class 布局的按钮​ 这一小节使用了两组不同的约束。一组是在 Any-Any 这种 size class 下安装的，这些约束定义了一对等宽的 button，跟 2.3.5 两个等宽的按钮 一样。 ​ 另外一组是在 Compact-Regular 这种 size class 下安装的。这些约束定义了一个叠一个的一对 button ，如下图所示。 ​ 垂直叠着的俩 button 是在 iPhone 的竖屏下使用的。水平一行的 button 在哪儿都能用。 约束 ​ 像 2.3.5 两个等宽的按钮 一样布局这俩 button 。在 Any-Any 这个 size class下，设置 1-6 的约束。 ​ 然后，把 Interface Builder 的 size class 修改成 Compact-Regular 布局。 ​ 卸载约束 2-5 ，然后添加约束7、8、9。 Short Button.Leading = Superview.LeadingMargin Long Button.Leading = Short Button.Trailing + Standard Long Button.Trailing = Superview.TrailingMargin Bottom Layout Guide.Top = Short Button.Bottom + 20.0 Bottom Layout Guide.Top = Long Button.Botton + 20.0 Short Button.Width = Long Button.Width Long Button.Leading = Superview.LeadingMargin Short Button.Trailing = Superview.TrailingMargin Long Button.Top = Short Button.Bottom + Standard 属性 ​ 给 button 一个看得见的背景颜色，这样当设备旋转的时候我们可以更容易的看出它们 frame 的。另外，button 们使用不一样的标题，这么做是为了显示 button 标题并不影响 button 的宽。 View Attribute Value Short Button Background Light Gray Color Short Button Title short Long Button Background Light Gray Color Long Button Title Much Longer Button Title 讨论 ​ Interface Builder 让你可以设置特定 size class 的视图、视图属性、约束。同时，它允许你为宽度和高度指定三个不同大小的不同的选项（Compact、Any、Regular），总共有9个不同的 size classes。其中的4个是最终的 size classes。，使用在具体设备上的（Compact-Compact、Compact-Regular、Regular-Compact、Regular-Regular）。其余的是基本 size classes，或者说抽象的代表两个或更多 size class 的 size classes（Compact-Any, Regular-Any, Any-Compact, Any-Regular, and Any-Any）。 ​ 当加载给定 size class 的布局的时候，系统为那个 size class 加载最详细的设置。这意味着 Any-Any这个 size class 定义的是所有视图使用的默认内容。Compact-Any 的设置影响所有有 compact 宽的视图，Compact-Regular 设置仅仅是由 compact 宽、regular 高的视图使用。当 size class 改变时，比如，当 iPhone 旋转到横屏时，系统会自动切换布局而且是以动画的形式。 ​ 你可以使用这个特性针对 iPhone 的不同方向来创建不同的布局。你也可以为 iPhone 和 iPad 创建不同的布局。size class 的定制既可以宽泛又可以简单。当然，越多的改变，故事板就越复杂，设计、维护的难度也会增加。 ​ 请记住，你需要确保让每一个 size class 都有一个可用的布局。包括所有的 基本 size classes。一般的法则是，一般很容易给所有的布局选出一个默认布局，在 Any-Any 中设计这个布局。然后按照需求修改最终 size classes。请记住，你可以在程度更加精确的布局中添加或者移除项。 ​ 对于更加复杂的布局，你可能想绘制出 9x9 大小的 size class 网格。为四个角落里的 size classes 给出布局。通过这个网格我们能发现哪个约束是在多个 size classes 之间共享的，这能帮助你找到最好的布局组合和 size classes 选择。 ​ 想要了解更多关于使用 size classes 的信息，查看 3 调试 Auto Layout 。 调试 Auto Layout错误类型​ Auto Layout 中的 error 可以被分为以下主要的三类： Unsatisfiable Layouts. 你的布局没有可用的解决方案。查看 3.2 不能满足的布局 获取更多信息。 Ambiguous Layouts. 你的布局有两种或者更多的解决方案，查看 3.3 歧义的布局 获取更多信息。 Logical Errors. 你的布局逻辑中有 bug。查看 3.4 逻辑错误 获取更多信息。 大部分时间，真正的问题是定位哪里出错了。你添加了你认为需要的约束，但是运行时，却没有按照你希望的发生。 ​ 一般，只要你理解问题，解决方法很明了。移除矛盾的约束，添加缺失的约束，调整优先级，就可以了。当然，在你能很容易地理解这个问题之前可能需要一些进行尝试和错误。像任何技能一样，实践会让一切变的容易。 ​ 有时候，然而，事情变得复杂。这时候需要看的是 3.5 调试技巧和提示 。 不能满足的布局​ 当系统面对当前的约束集合，不能找到一个可行的解决方案的时候，这时候的布局就是不能满足的布局。两个或者更多的 required 约束放生了冲突，因为它们不能同时满足。 确认不能满足的约束​ Interface Builder 常常能在设计的时候就侦测到冲突。在这种情况下，Interface Builder 以下列几种方式显示发生的错误： 所有冲突的约束在画布中是红色的。 Xcode 会把冲突的约束当成 warnings ，会在 issue navigator 中列出。 Interface Builder 会在文档大纲的右上角，展示一个红色的小三角展开按钮。 ​ 点击红色的小三角展开按钮，会列出当前布局中所有的 Auto Layout issues。 ​ Interface Builder 回经常建议修复这些 issues。想要了解更多，查看 Auto Layout Help 中的 Resolving Auto Layout Issues for a View Controller\\Window\\or Root View 。 NOTE 尽管 Interface Builder 提供的即时反馈让我们更容易地创建出可用的布局，但是它并不能发现所有可能的布局错误。 比如，Interface Builder 只能侦测出画布当前 size class 的冲突。但是，另外一些冲突，只有在 root view 被拉伸或者压缩得超过某个值的时候（或者当内容扩展或压缩得超过某个值的时候）才会发生。Interface Builder 不能侦测到这些错误。 所以，尽管我们总是修复了 Interface Builder 确定的所有 issues，修复这些明显的错误是不够的。还是得进行运行时测试，针对所有的屏幕尺寸、屏幕方向、所有动态文本大小、所有你想支持的语言。 ​ 当系统在运行时发现布局不能满足的时候，它会做以下几步： Auto Layout 确定冲突的约束们。 系统会打破冲突约束中的一个，检查布局。直到找到可用的布局之前，系统会继续打破约束。 Auto Layout 会把冲突的约束的信息、被打破的约束的信息打印到控制台。 这个能“回退”的系统让应用程序继续下去，同时仍然试图给用户呈现一些有意义的东西。但是，不同的布局打破约束的效果会有很大的不同，甚至同一布局每次 build 之间都会有不同。 ​ 在很多情况下，缺失的约束可能没有任何明显的影响。视图层级会如我们所期望的那样显示。在其他情况下，确实的约束可能会导致视图层级的整个部分都是错误位置、错误大小，或者都消失。 ​ 当它们没有明显的影响时，往往会忽略错误，毕竟它们不会改变应用程序的行为。但是，对视图层级或SDK的任何更改也可能会改变被打破的约束们，突然间，明显的破坏布局。 ​ 因此，当发现无法满足的约束的时候，一定要修复它。问了确保在测试时我们能捕捉到不明显的错误，可以为 UIViewAlertForUnsatisfiableConstraints 设置一个 symbolic breakpoint。 阻止不能满足的约束​ 不能满足的约束，相对来说比较容易修复。系统会告诉我们不能满足的约束是什么时候发生，而且会提供一个冲突约束的列表。 ​ 只要你知道这个错误，解决办法一般是很简单的。要么移除一个约束，要么把它改成可选的约束（修改优先级）。 ​ 然而，还是有一些常见的 issue 值得详细研究： 不能满足的约束经常发生在，以编程的方式往视图层级中添加视图的时候。新的视图的 translatesAutoresizingMaskIntoConstraints 属性默认是 YES。当在对画布中的 view 添加约束的时候，Interface Builder 会自动把这个属性设为 NO。但是，当我们通过编程的方式创建和布局视图的时候，我们需要把这个属性设置为 NO，然后再添加我们自己的、自定义的约束。 不能满足的约束经常发生在，当一个视图层级显示在对于它来说太小的空间里。您通常可以预测你的视图能够访问的最小空间，并适当地设计你的布局。但是，国际化和动态文本都有可能让视图的内容比期望的要大。随着可能的排列数量的增加，保证布局在所有情况下都好使变得越来越困难。 相反，你可能想要基于出错的点来构建运行，这样你的布局就会以一种可预测的、可控的方式失败。 考虑将您的一些 required 约束转换为高优先级的 optional 约束。这些高优先级的 optional 约束让你可以控制在冲突发生时布局将会打破的位置。 例如，给我们出错的点一个 999 的优先级。在大多数情况下，这么高优先级的约束就好像是 required 的一样；不过，当发生冲突时，高优先级的约束被打破，保护余下的布局。类似的，应该避免给那些具有固定内容大小的视图的 content-hugging 和 compression resistance 一个 required 的优先级。通常，控件的大小可以是一个理想的出错点。控件可以变得更大或更小，而对布局有任何有意义的影响。 试的，有些空间只能以固有内容大小呈现；但是，即使在这些情况下，最好还是有一些控制，而不是仅仅让你的布局以不可预知的方式打破。 歧义的布局​ 当系统的约束有两种或者多种可用的解决方案的时候，就会发生歧义的布局。主要原因有两个： 布局需要额外的约束来唯一地确定每一个视图的位置和位置。（大小？） 当你确定哪那个视图是歧义的，只管添加约束来唯一地确定这个视图的位置和大小。 布局发生冲突着的约束中，有一样优先级的，这时候，系统不知道该打破哪一个约束了。 这时候，你需要告诉系统该打破哪一个约束，怎么做，修改优先级让他俩的优先级不一样就好了。系统会首先打破那个优先级低的那个约束。 侦测歧义的布局 ​ 跟对待不能满足的约束一样，Interface Builder 常常在设计时就能探测到有歧义的布局，同时提供修复的建议。这些歧义会以 warning 的形式出现在 issues navigator 中，在文档大纲中以 error 形式出现，在画布中以红线的形式出现。想要了解更多信息，查看 3.2.1 确认不能满足的约束 。 ​ 跟不能满足的约束一样，Interface Builder 不能侦查出所有可能的歧义。很多错误只有在测试中才会发现。 ​ 当在运行时发生有歧义的布局的时候，Auto Layout 选择一个可能的解决方案。这意味着跟你期望的布局可能会不一样。而且，没有 warning 会输出到控制台，所以对于有歧义的布局没办法设置断点。 ​ 结果就是，有歧义的布局常常比那些不能满足的布局更难以侦测和确定。就算歧义导致了明显的、看得见的影响，还是很难确定这个错误是因为歧义还是布局逻辑中的错误。 ​ 幸运的是，还是有几个能确定歧义布局的方法来供我们调用的。所有这些方法只应该在调试的时候用。在一个地方设置断点，要保证你在这里能访问到视图层级，然后在控制台里调用以下方法： hasAmbiguousLayout . iOS、OS X 都可用。如果遇到视图错位的情况，调用这个方法。如果视图的 frame 是歧义的，就会返回 YES，否则 NO。 exerciseAmbiguityInLayout . iOS、OS X 都可用。如果一个视图布局歧义的话，调用这个方法。这个会让系统在可能的可用解决方案中切换。 constraintsAffectingLayoutForAxis: . 仅 iOS 可用。对一个视图调用这个方法。它将返回一个数组，它包括在指定的轴上影响该视图的所有约束。 constraintsAffectingLayoutForOrientation: . 仅 OS X 可用。对一个视图调用这个方法。它将返回一个数组，它包括在指定的方向上影响该视图的所有约束。 _autolayoutTrace . 作为私有方法，仅 iOS 可用。对一个视图调用这个方法。这个方法会返回一个字符串，这个字符串包含了该视图的整个视图层级的诊断信息。有歧义的视图被标记了，translatesAutoresizingMaskIntoConstraints 属性设置成 YES 的视图也会被标记。 在控制台上运行这些指令的时候，你可能需要用到 Objective-C 的语法。比如，当停在断点的时候，在控制台输入 call [self.myView exerciseAmbiguityInLayout] 来调用 myView 的exerciseAmbiguityInLayout 方法。类似地，输入 po [self.myView autolayoutTrace] 会打印出包含 myView 的视图层级的诊断信息。 NOTE 要确保在运行上述的诊断方法之前，修复了 Interface Builder 发现的所有 issues。Interface Builder 尝试修复它发现的所有错误。这意味着，如果 Interface Builder 发现了歧义的布局，它会添加约束来让布局不再歧义。 因此，hasAmbiguousLayout 返回 NO。 exerciseAmbiguityInLayout 似乎没有任何效果，constraintsAffectingLayoutForAxis: 可能返回额外的、不是我们预期的约束。 逻辑错误​ 逻辑错误就是 bug。你在某个地方有一个错误的假设。可能这个假设是关于 Auto Layout 是如何计算视图的 frames 的。也可能这个假设是关于你创建的约束集，或者是关于你设置的视图的属性。有可能这个假设是关于约束们是如何交互进而来创建复杂的行为的。无论如何，肯定有哪不符合我们的心里所想。 ​ 逻辑错误最难找。在你排除了其他所有可能性后，尽管不太可能发生，但是无论剩下的是啥，肯定是逻辑错误。然而，尽管在你确定了这是一个 bug 以后，你还是需要找到究竟是在哪做了这个错误的假设。 ​ 这里，既没有工具，也没有一步一步的指导。修复逻辑错误一般会涉及实验和不停的测试，主要是为了确定问题所在、想出修复的办法。但是还是有几个能帮上忙的建议： 过一遍现在的约束集。确保没有错过任何约束，也没有意外加了预期外的约束。要确保所有的约束都是正确的项和正确属性。 仔细检查视图的 frame。确保没有任何东西被意外地拉伸或者压缩。 这对那些有着看不见背景的视图来说格外重要，比如 label 、button。当这些东西被意外地调整大小的时候，不是很明显。 大小被调整的一个症状是，与 baseline 对齐的视图不再正确地对齐。这是因为，baseline 对齐只有在视图以它固有内容高度呈现时才好使。如果你在垂直方向上拉伸或者压缩视图的话，文本会神秘地出现在错误的地方。 如果一个控件需要一直保持它的固有内容大小，给它设置一个很高的 content-hugging 和 compression-resistance 优先级（比如，999）。 查一遍关于布局的所有假设，并添加明确的约束，以确保这些假设是正确的。 请记住，不能满足的布局一般是最容易发现和修复的。有了冲突再添加额外的约束，然后检查、解决冲突。 试着理解为什么设置的约束会产生我们所看到的结果。如果你理解的这个过程的话，在修复它的路上，你会很快上道。 用可代替的约束做实验。自动布局通常会为同一问题提供许多不同的解决方案。尝试一种不同的方法可以解决这个问题，或者至少可以更容易地发现错误。 调试技巧和提示​ 以下的几个题目描述了获取、组织布局相关信息的技术，也介绍了你可能会遇到的让人吃惊的行为。你不需要再每个布局上都用这些技术，但是在最困难的问题上它们能帮上忙的。 理解 Logs​ 视图的相关信息能在控制台被打印出来，两种情况下会被打印出来。要么是因为存在无法满足的布局，要么是因为我们通过 constraintsAffectingLayoutForAxis: 和 constraintsAffectingLayoutForOrientation: 这俩调试方法明确的输出约束相关的日志。 ​ 不管是哪种方法，我们都能在日志中找到好多有用的信息。下面是一个不能满足布局错误的简单的输出： 1234567891011121314152015-08-26 14:27:54.790 Auto Layout Cookbook[10040:1906606] Unable to simultaneously satisfy constraints. Probably at least one of the constraints in the following list is one you don&apos;t want. Try this: (1) look at each constraint and try to figure out which you don&apos;t expect; (2) find the code that added the unwanted constraint or constraints and fix it. (Note: If you&apos;re seeing NSAutoresizingMaskLayoutConstraints that you don&apos;t understand, refer to the documentation for the UIView property translatesAutoresizingMaskIntoConstraints) ( &quot;&lt;NSLayoutConstraint:0x7a87b000 H:[UILabel:0x7a8724b0&apos;Name&apos;(&gt;=400)]&gt;&quot;, &quot;&lt;NSLayoutConstraint:0x7a895e30 UILabel:0x7a8724b0&apos;Name&apos;.leading == UIView:0x7a887ee0.leadingMargin&gt;&quot;, &quot;&lt;NSLayoutConstraint:0x7a886d20 H:[UILabel:0x7a8724b0&apos;Name&apos;]-(NSSpace(8))-[UITextField:0x7a88cff0]&gt;&quot;, &quot;&lt;NSLayoutConstraint:0x7a87b2e0 UITextField:0x7a88cff0.trailing == UIView:0x7a887ee0.trailingMargin&gt;&quot;, &quot;&lt;NSLayoutConstraint:0x7ac7c430 &apos;UIView-Encapsulated-Layout-Width&apos; H:[UIView:0x7a887ee0(320)]&gt;&quot;) Will attempt to recover by breaking constraint&lt;NSLayoutConstraint:0x7a87b000 H:[UILabel:0x7a8724b0&apos;Name&apos;(&gt;=400)]&gt; Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger.The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in &lt;UIKit/UIView.h&gt; may also be helpful. ​ 这个错误信息显示了5个冲突的约束。这些约束不能同时满足。我们需要要么移除一个，要么把它转换成可选优先级的约束。 ​ 幸运的是，这个视图层级相对简单。我们有一个包含一个 label 和一个 text field 的父视图。冲突的约束设置以下的关系： label 的宽大于等于 400 points。 label 的 leading edge 跟父视图的 leading margin 相等。 label 与 text field 之间 8 points 的间隔。 text field 的 trailing edge 跟父视图的 trailing margin 相等。 父视图的宽设置为 320 points。 系统会通过打破 label 的宽来尝试修复布局。 NOTE 在控制台输出的约束使用的是 Visual Format Lanuage。尽管我们从没用 VFL 来创建约束，但是为了有效地进行 Auto Layout 调试，我们得具备阅读、理解这个语言的能力。想要了解更多，查看 Visual Format Language 。 ​ 在这些约束中，最后一个是系统创建的，我们没办法修改它。而且，它跟第一个约束有明显的冲突。如果你的俯视图宽只有 320 points，你永远不可能会有一个 400 points 宽的 label 的。幸运的事，你不需要摆脱第一个约束。如果你把它的优先级降为 999，系统仍会试着提供所选择的宽——尽可能的近同时满足其他余下的约束。 ​ 基于一个视图的 autoresizing mask 的约束（比如，当 translatesAutoresizingMaskIntoConstraints 为 YES 时创建的约束），这些约束有额外的信息，这些信息是关于 mask 的。在这些约束的地址后面，日志字符串显示，h= 后面有3个字符，v= 后面有3个字符。一个 - （连字符）意味着一个固定值，而一个 &amp; 符号意味着一个可变的值。对水平方向的 mask 来说（h=），这三个字符分别意味着：left margin 、width、right margin。对于垂直方向的 mask 来说（v=），这三个字符分别意味着：top margin 、height、bottom margin。 ​ 比如，看这条日志信息： 1&lt;NSAutoresizingMaskLayoutConstraint:0x7ff28252e480 h=--&amp; v=--&amp; H:[UIView:0x7ff282617cc0(50)]&gt;&quot; ​ 该信息包含以下几部分： NSAutoresizingMaskLayoutConstraint:0x7ff28252e480: 约束的类和地址。在这个例子中，这个类告诉你它基于一个视图的 autoresizing mask。 h= - - &amp; v= - - &amp; ：该视图的 autoresizing mask。这是默认的 mask。水平方向上它有一个固定值的 left margin 、一个固定值的 width、一个可变的 right margin。垂直方向上，它有一个固定值的 top margin 、一个固定值的 height、一个可变的 bottom margin。换句话说，视图的左上角和大小都是常数，在父视图的大小改变时保持不变。 H : [ UIView : 0x7ff282617cc0(50) ] : 约束的 visual format language 描述。在这个例子中，定义了一个单一视图，宽是一个常数值 50 points。这个描述也包括了类名和受这个约束影响的视图的地址。 给 Logs 添加标识符​ 尽管先前的例子理解起来相对简单，较多的约束的情况很快就让人难以跟上。我们可以通过给每一个视图、约束一个有意义的标识符，一次来让输出日志更容易阅读一些。 ​ 如果视图有一个明显的文本元素，Xcode 会以此作为标识符。比如，Xcode 使用 label 的 text 、button 的 title、text field 的占位符来标识这些视图。否则，在标识检查器中设置视图的 Xcode 特定标识符。Interface Builder 在它的界面中使用这些标识符。其中许多还显示在控制台日志中。 ​ 设置约束的标识符属性，可以通过编程的方式或者使用属性检查器。设置好后，Auto Layout 在控制台打印信息的时候就会使用这些标识符。 ​ 比如，这是同一个不能满足的约束错误，但是标识符是设置好的： 1234567891011121314152015-08-26 14:29:32.870 Auto Layout Cookbook[10208:1918826] Unable to simultaneously satisfy constraints. Probably at least one of the constraints in the following list is one you don&apos;t want. Try this: (1) look at each constraint and try to figure out which you don&apos;t expect; (2) find the code that added the unwanted constraint or constraints and fix it. (Note: If you&apos;re seeing NSAutoresizingMaskLayoutConstraints that you don&apos;t understand, refer to the documentation for the UIView property translatesAutoresizingMaskIntoConstraints) ( &quot;&lt;NSLayoutConstraint:0x7b58bac0 &apos;Label Leading&apos; UILabel:0x7b58b040&apos;Name&apos;.leading == UIView:0x7b590790.leadingMargin&gt;&quot;, &quot;&lt;NSLayoutConstraint:0x7b56d020 &apos;Label Width&apos; H:[UILabel:0x7b58b040&apos;Name&apos;(&gt;=400)]&gt;&quot;, &quot;&lt;NSLayoutConstraint:0x7b58baf0 &apos;Space Between Controls&apos; H:[UILabel:0x7b58b040&apos;Name&apos;]-(NSSpace(8))-[UITextField:0x7b589490]&gt;&quot;, &quot;&lt;NSLayoutConstraint:0x7b51cb10 &apos;Text Field Trailing&apos; UITextField:0x7b589490.trailing == UIView:0x7b590790.trailingMargin&gt;&quot;, &quot;&lt;NSLayoutConstraint:0x7b0758c0 &apos;UIView-Encapsulated-Layout-Width&apos; H:[UIView:0x7b590790(320)]&gt;&quot;) Will attempt to recover by breaking constraint&lt;NSLayoutConstraint:0x7b56d020 &apos;Label Width&apos; H:[UILabel:0x7b58b040&apos;Name&apos;(&gt;=400)]&gt; Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger.The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in &lt;UIKit/UIView.h&gt; may also be helpful. ​ 正如我们看到的那样，这些标识符让我们可以很快很容易地在日志中辨别出约束。 可视化视图和约束​ Xcode 提供了一些工具，帮助您在视图层级中让视图和约束可视化。 ​ 想要在模拟器中看到视图： 在模拟器中运行 app。 切回 Xcode。 选择 Debug &gt; View Debugging &gt; Show Alignment Rectangles。这个设置会描绘视图的边缘。 ​ Alignment Rectangles 是 Auto Layout 所使用的边缘。打开这个选项，让您可以快速地发现任何被意外调整大小的 Alignment Rectangles 。 ​ 如果你需要更多的信息，点击 Xcode 调试栏的 Debug View Hierarchy 按钮（）。Xcode 会显示一个能交互的调试视图，提供了一些探索视图层级、与视图层级交互的工具。当调试 Auto Layout issues 时，Show clipped content 和 Show constraints 选项特别有用。 ​ 选中 Show clipped content 选项，会显示那些可能已经被意外地移除屏幕的视图的位置。选中 Show constraint 选项，会显示所有能影响当前选中视图的约束集。当发生奇怪行为的时候，这两个选项都提供了快速的检查。 ​ 想要了解更多信息，查看 Debug Area Help。 理解边缘情况​ 以下几种边缘情况，会导致 Auto Layout 有意想不到的行为。 Auto Layout 基于视图的 Alignment Rectangles 设置它们的位置，而不是用 frame。大部分情况下，二者的值时相等的。但是，一些视图可能会设置一个自定义的 Alignment Rectangles ，以此将视图的某些部分从布局计算中排除（比如，badges）。 想要了解更多信息，查看 UIView Class Reference 中的通过 Auto Layout 对齐视图。 在 iOS 中，我们可以使用一个视图的 transform 属性来调整视图的大小、旋转、移动；但是，在任何情况下，这些 transformations 都不会影响 Auto Layout 的计算。Auto Layout 会基于一个视图的 untransformed frame来计算它的 Alignment Rectangles 。 一个视图可以在它的边界之外显示内容。大部分情况下，视图行为比较正常，并将其内容限制在其边界内。但是，由于性能方面的原因，这并不是由图形引擎强制执行的。这意味着视图可能会以不同于 frame 的大小被绘制（特别是自定义绘制的视图）。 您可以通过将视图的 clipsToBounds 属性设置为 YES 或通过验证视图 frame 的大小来确认这些错误。 NSLayoutAttributeBaseline、NSLayoutAttributeFirstBaseline、NSLayoutAttributeLastBaseline 这三个属性，只有在所有的视图都以它们的固有内容高度显示时，才会正确地对齐文本。如果其中的一个视图在垂直方向上被拉伸或者收缩了，它的文本就会出现在错误的位置上。 约束优先级在整个视图层级中，扮演者全局属性的角色。我们常常可以通过 layout guide、虚拟视图或者通过把几个视图编组然后放在一个 stack view 中这样的方式，来简化我们的布局；然而，这种方法没有封装所包含的视图的优先级。Auto Layout 还是会比较组内的视图和组外视图的优先级（或者甚至其他组内视图的优先级）。 高宽比约束允许水平方向上的约束和垂直方向上的约束交互。一般地，水平布局和垂直布局是分开计算的。但是，如果你约束了一个视图高与宽的关系，就等于建立了水平方向约束与竖直方向约束的关系：它们就能影响彼此甚至发生冲突。这些交互会极大地增加你布局的复杂程度，也有可能导致该视图与不相关的部分之间的意外冲突。 Auto Layout 进阶编程的方式创建约束​ 无论何时，尽可能地使用 Interface Builder 来设置约束。Interface Builder 提供了很多工具来可视化、编辑、管理和调试你的约束。通过分析你的约束集，Interface Builder 还会在设计时就发现一些常见的错误，让你甚至在运行 App 之前就可以发现并修改错误。 ​ Interface Builder 能管理越来越多的任务。你可以直接在 Interface Builder 中创建几乎所有类型的约束（查看 1.4 在 Interface Builder 中使用约束）。你也可以创建不同 size class 的约束（查看 3 调试 Auto Layout），通过使用 stack views 等新工具，你甚至可以在运行时动态地添加、移除一个视图（查看 2.1.3 动态 Stack View）。但是，一些动态地视图层级的改变还是只能通过代码管理。 ​ 通过编程的方式创建约束有三种方法：使用布局锚点、使用 NSLayoutConstraint 类、使用 Visual Format Language 语言。 布局锚点​ NSLayoutAnchor 类为创建约束提供了一个连贯的接口。要使用此API，得访问要约束的视图的锚点属性。比如，视图控制器的 top layout guide 和 bottom layout guide 有 topAnchor 属性、bottomAnchor 属性和 heightAnchor 属性。视图的话，为它们的 edges、centers、size、baselines 暴露了锚点。 NOTE 在 iOS 中，视图还有 layoutMarginsGuide 属性和 readableContentGuide 属性。这俩属性暴露出 UILayoutGuide 类的接口，分别代表了视图的 margin 和 readable content guides 。这些 guides，依次为它们的 edges、centers、size 暴露了锚点。 当通过编程的方式创建与 margins 或者 readable content guides 之间的约束时，使用这些 guides。 ​ 布局锚点，让我们以一种易于阅读的紧凑格式来创建约束。它们有一系列创建不同类型约束的方法，如 Listing 13-1 所示。 Listing 13-1 创建布局锚点 1234567891011// Get the superview&apos;s layoutlet margins = view.layoutMarginsGuide // Pin the leading edge of myView to the margin&apos;s leading edgemyView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true // Pin the trailing edge of myView to the margin&apos;s trailing edgemyView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true // Give myView a 1:2 aspect ratiomyView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true ​ 正如 1.3 解剖“一个约束” 中描述的，一个约束仅是一个线性等式。 ​ 布局锚点有几种不同的创建约束的方法。每种方法只包含等式中影响结果的元素参数。所以在下面的一行代码中： 12&gt;myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true&gt; 这些符号对应于等式的以下部分： Equation Symbol Item 1 myView Attribute 1 leadingAnchor Relationship constraintEqualToAnchor Multiplier None (defaults to 1.0) Item 2 margins Attribute 2 leadingAnchor Constant None (defaults to 0.0) ​ 布局锚点也提供了额外的类型安全。NSLayoutAnchor 类有很多子类，这些子类添加了类型信息，也增加了子类特有的创建约束的方法。这阻止了不可用约束的意外创建。比如，你只可以约束水平锚点（ leadingAnchor 或者 trailingAnchor ）与其他水平锚点之间的关系。类似地，你也只能为大小约束提供 multipliers。 NOTE 这些规则并不是由 NSLayoutConstraint API 强制执行。相反，如果你创建了一个不可用的约束，这个约束会在运行时抛出异常。因此，布局锚点，是在帮我们把运行时的错误转变成编译期的错误。 想要了解更多相关信息，查看 NSLayoutAnchor Class Reference 。 使用 NSLayoutConstraint 类​ 你也可以直接使用 NSLayoutConstraint 类的 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 快捷创建方法来创建约束。这个方法显式地将约束方程转换为代码。每一个参数对应于等式中的一个部分。 ​ 与布局锚点 API 所采用的方法不同，你必须确定每一个参数的值，就算它对布局没有影响也得确定。最终结果是大量的样板代码，很难阅读。比如，Listing 13-2 的代码在功能上与 Listing 13-1 是等价的。 Listing 13-2 直接实例化约束 12345NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true NOTE 在 iOS 中， NSLayoutAttribute 枚举值包含了视图 margins 的值。这意味着你可以直接创建与 margins 之间的约束，不用通过 layoutMarginsGuide 属性。但是，你仍然需要使用 readableContentGuide 属性来创建与 readable content guides 之间的约束。 不同于布局锚点 API ，快捷创建方法没有强调特定约束的重要性。结果就是，在浏览代码时，很容易错误重要细节。另外，编译器不会为约束做任何静态分析。你可以随意地创建不可用的约束，这些约束会在运行时抛出异常。因此，要是不需要支持 iOS 8 或者 OS X v10.10 或者更早之前的系统，考虑一下把代码迁移到最新的布局锚点 API 吧。 ​ 想要了解更多信息，查看 NSLayoutConstraint Class Reference 。 使用 Visual Format Language 语言​ Visual Format Language 语言让你使用 ASCII-art like strings 来定义你的约束。这给约束提供了一个较为直观的描述。Visual Format Language 有以下优点和缺点： Auto Layout 使用 Visual Format Language 在控制台打印出约束；因为这个圆心，调试信息跟创建约束的代码信息就很像。 Visual Format Language 让你可以同时创建多个约束，使用一个紧凑的表达式。 Visual Format Language 让我们只创建出可用的约束。 Visual Format Language 相对于完整性，更强调可视化。因此，一些约束（比如，高宽比）不能使用该语言来创建。 编译器不会以任何方式来验证这个字符串。我们只能通过运行时测试来发现错误。 Listing 13-1 中的示例用 Visual Format Language 重写如下： Listing 13-3 用 Visual Format Language 创建约束 123456let views = [\"myView\" : myView]let formatString = \"|-[myView]-|\" let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views) NSLayoutConstraint.activate(constraints) ​ 这个例子创建并激活了 leading 约束和 trailing 约束。当使用默认间隔时， Visual Format Language 总是创建与父视图的 margin 之间 0 point 的约束，所以这些约束跟之前的例子是等价的。但是 Listing 13-3 不能创建高宽比约束。 ​ 如果你创建一个一行上有多个项的这样一个复杂点的视图，Visual Format Language 会指定垂直对齐和水平间距。正如所写的，“alignAllTop” 选项不影响布局，因为该例子只有一个视图（不算父视图的话）。 使用 Visual Format Language 创建约束： 创建 view 字典，这个字典必须作为 key 的字符串和作为值的视图（或是其他在 Auto Layout 中可以被学术的项，比如 layout guides）。使用 key 来标识格式字符串中的视图。 NOTE 当使用 Objective-C 的时候，使用 NSDictionaryOfVariableBindings 宏来创建 view 字典。用 Swift 的话，自己创建。 （Optional）创建 metrics 字典。这个字典必须有作为 key 的字符串，和作为值的 NSNumber 对象。用 key 来代表格式字符串中的常量。 通过布局一个单行或者单列元素来创建格式字符串。 调用 NSLayoutConstraint 类的 constraintsWithVisualFormat:options:metrics:views: 方法。这个方法返回一个包含所有约束的数组。 通过调用 NSLayoutConstraint 类的 activateConstraints: 方法来激活约束。 想要了解更多相关信息，查看 Visual Format Language 附录。 Size-Class-Specific 布局​ Interface Builder 中的 Storyboards 默认是使用 用 size classes 的。 size classes 像场景、视图一样，是分配给用户界面元素的特性，给用户界面的这些元素的大小提供了一个粗略指示。Interface Builder 允许我们自定义好多布局的特征，不过仅限于当前的 size class 。但是随 size class 的改变，布局会自动的进行适应变化。具体来说，你可以在每个 size class 的基础上设置以下特性： 安装或着卸载一个视图或者一个控件。 安装或着卸载一个约束。 设置选中特征的值。（比如，字体和布局的边距设置等） 当系统加载一个场景时，它会实例化所有的视图，控件，约束，然后把这些东西和视图控制器中的相应的outlet 连接好（如果有的话）。无论该场景，当前的 size class 是什么，我们都能访问到这些控件和视图。然而，只有在当前 size class 安装了这些视图、控件的情况下，系统才会把这些视图、控件添加到视图层级中去。 随着视图的 size class 的改变（比如，旋转 iPhone，或者是 iPad应用在全屏和 Split View 之间切换的时候），系统自动地从视图层级中添加或着移除这些视图、控件。系统对于布局的变化，采用平滑的动画过渡。 NOTE 系统对对那些卸载的视图、控件会保留引用，所以当它们从视图层级移除时，并不是 deallocated 。 最终 size classes 和基本 size classes​ Interface Builder 可以识别出 9 种不同的 size classes。 ​ 其中四种是 最终的 size classes ：Compact-Compact， Compact-Regular，Regular-Compact，and Regular-Regular 。 Compact = 紧缩 ，Regular = 正常。 最终的 size classes 代表的是设备上展示的实际的 size classes。 ​ 剩下的五种是 基本的 size classes ：Compact-Any，Regular-Any， Any-Compact，Any-Regular，Any-Any。Any = 任何 。这些 size classes 代表着两种或着更多种的 最终的 size classes 。举个例子，在 Compact-Any 这个 size classes 上安装的视图、控件，会在 Compact-Compact 和 Compact-Regular 这两种 size classes 的视图上出现。 ​ 在一个更加精确的 size class 上做的设置，会覆盖一个相对通用的 size class 上做的设置。另外，我们必须为9个 size classes 均提供出准确的、可实现满足的布局，包括5种 基本的 size classes 。因此，一贯最简单的方式，是从最通用的 size class 着手，进而到最精确的 size class。为你的App选择默认的布局，在 Any-Any 的 size class 中，设计实现这个布局。然后根据你的需求，去修改其他的 最终的 size classes 或是 基本的 size classes 。 使用 Size Class 工具​ 我们通过使用 Interface Builder 的 Size Class 工具 来选择当前正在编辑的 size class。该工具位于 Interface Builder 编辑窗口的底部正中间。Interface Builder 默认情况下选中的 size class 是 Any-Any，我们可以从这个 size class 开始干活。 想要切换到另外一个 size class，点击 Size Class 工具 。Interface Builder 会弹出一个视图，这个视图包含一个 3 x 3的网格。通过在网格上移动你的鼠标，来改变当前的 size class。该网格在上部展示选中的 size class 的名字，在下部展示当前 size class 的一个描述（包括所影响的设备、方向）。It also displays a green dot in each size class affected by the current size class（不知道怎么翻译，Xcode9的界面已经改变）。 任何添加到画布上的视图、约束，仅仅是在当前的 size class 中被安装。当删除这些视图、约束的时候，这个删除行为会根据删除的位置、方式有所不同。 从画布或文件大纲中删除一个条目将完全从项目中删除。 从画布或文件大纲中 Command-Deleting 一个条目，只会从当前的 size class 中卸载该条目。 当一个场景有不止一个 size class 的时候，从画布或者文件大纲以外的任何一个地方删除一个条目（比如，在尺寸检查器中选择并删除一个约束），只是在当前 size class 中卸载该条目。 如果你仅在 Any-Any 这个 size class 中进行编辑过，那么，删除一个条目会把它从工程中删除。 如果你正在编辑一个 Any-Any 以外的 size class ，Interface Builder 会将编辑窗口底部的工具栏高亮（蓝色）。这样的话，你是否有使用更加精确的 size class，就比较明显了。 4.2.3 使用检查器​ 我们也可以在检查器中修改 size class 特定的设置。任何支持 size class 特定设置的东西都会出现在检查器中，旁边有一个小的加号图标。 默认情况下，检查器设置的是 Any-Any size class 的值。如果想要设置别的 size class 的值的话，点击加号图标添加一个新的 size class。然后分别为你想添加的 size class 选择宽（紧缩、正常、任意）和高（紧缩、正常、任意）。 添加成功后，检查器会将每一个添加的 size class 罗列成一个队列，自上而下，Any-Any 的设置在最上边，下面罗列的是较为精确的 size classes。它们之间的值的修改是相互独立的。 想要删除哪个添加的 size class 的话，点击前面的叉号图标。 想了解关于如何在 Interface Builder 中使用 size classes 的更多相关信息，请查看 Size Classes Design Help 。 Working with Scroll Views​ 当使用 scroll views 时，你需要在 scroll view 的父视图中定义其 frame 的大小和位置，以及 scroll view 的 content 区域的大小。所有这些都可以使用 Auto Layout 来设置。 ​ 为了支持 scroll view ，系统根据约束所在的位置不同，来以不同的方式解释约束。 任何在 scroll view 和 scroll view 之外的对象的约束，都附加到 scroll view 的 frame 上，就像和其他视图一样。 对于 scroll view 和它内容之间的约束，会因为被约束的属性不同而产生不同的行为： scroll view 的 edge 、margins 和它的内容之间的约束是被附加到 scroll view 的内容区域。 scroll view 的 height、width、center 之间的约束是被附加到 scroll view 的 frame 上。 你也可以约束 scroll view 的内容和 scroll view 外边的对象之间的关系，以此来为 scroll view 的内容提供一个固定的位置，让内容看起来好像是漂浮在 scroll view 之上。 对于大多数普通的布局任务，如果你使用虚拟视图活着布局编组来包括住 scroll view 的内容，逻辑就会变得相当简单。当使用 Interface Builder 时，一般方法如下所示： 在场景中添加 scroll view。 跟平常一样给 scroll view 的大小、位置设置约束。 给 scroll view 添加一个 view。将视图的 Xcode 特定标签设置为内容视图（Set the view’s Xcode specific label to Content View）。 把 content view 的 top edge、bottom edge、leading edge、trailing edge 固定到 scroll view 的相关 edges 上。content view 此时，定义了 scroll view 的内容区域。 R E M E M B E R 在这一点上，content view 没有一个固定的大小。它能伸展和成长，以适合任何放在 content view 中的视图和控件。 （Optional）为了禁用水平方向上的滚动，需设置 content view 的宽与 scroll view 的宽相等。这时，content view 水平填充 scroll view 。 （Optional）为了禁用垂直方向上的滚动，需设置 content view 的高与 scroll view 的高相等。这时，content view 垂直填充 scroll view 。 在 content view 的内部布局 scroll view 的内容。在 content view 内向平常一样用约束来定位内容。 I M P O R T A N T 你的布局必须完整地定义 content view 的大小（除了第五、六步定义的地方）。为了基于内容的固有大小设置高度，你必须有一个完整的约束和视图链，从 content view 的 top edge 延伸到它的 bottom edge。类似，为了设置宽，你必须有一个完整的约束和视图链，从 content view 的 leading edge 延伸到它的 trailing edge。 如果你的 content 没有固有内容大小，你必须添加合适的大小约束，要么约束其与 content view 的关系，要么约束其与 content 的关系。 当 content view 比 scroll view 高的时候，默认开启垂直滚动。当 content view 比 scroll view 宽的时候，默认开启水平滚动。否则的话，默认是禁止滚动的。 Working with Self-Sizing Table View Cells​ 在 iOS 中，你可以使用 Auto Layout 来定义一个 table view cell 的高度；但是，这个特性默认是不可用的。 ​ 一般来说，一个 cell 的高度是由 table view delegate 的 tableView:heightForRowAtIndexPath: 方法确定的。为了使用 self-sizing table view cell ，你必须设置 table view 的 rowHeight 属性为 UITableViewAutomaticDimension 。还必须给 estimatedRowHeight 属性赋一个值。只要这俩属性设置好了，系统就用 Auto Layout 来计算这一行的真实高度。 12tableView.estimatedRowHeight = 85.0tableView.rowHeight = UITableViewAutomaticDimension ​ 接着，在 table view cell 的 content view 里布局 cell 的内容。为了定义 cell 的高，你必须有一个完整的约束和视图链（定义好高度），以此来填充 content view 的 top edge 到它的 bottom edge 之间的区域。如果你的视图有固有内容高度，系统会使用那些值。如果没有，你必须添加合适的高度约束，要么是约束与视图们的关系，要么约束与 content view 自己的关系。 ​ 另外，让 estimated row height 尽可能的精确。系统会基于这些估算高度值来计算一些项，比如 scroll bar 的高度。这些估算值越精确，用户体验就越流畅无痕。 NOTE 当使用 table view cell 的时候，你不能修改预定义内容（比如，textLabel、detailTextLabel、imageView 属性）的布局。 以下约束是支持的： 约束你的子视图相对于 cell 的 content view 的位置。 约束你的子视图相对于 cell 的 bounds 的位置。 约束你的子视图相对于 cell 的预定义内容的位置。 修改约束​ 一个约束的修改是指任何关于一个约束的底层数学表达式的变动（看 Figure 17-1）。你可以查看 1.3 解剖“一个约束” 了解更多关于约束等式的信息。 Figure 17-1 约束等式 ​ 下列的动作会修改到一个或者更多的约束： 激活、或者注销一个约束。 修改约束的常量值。 修改约束的优先级。 把一个视图从视图层级中移除。 除这些以外的其他变动，比如设置一个控件的属性，或者修改视图层级，也能修改约束。当一个约束的修改发生时，系统会调度一个 deferred layout pass （查看 4.5.1 The Deferred Layout Pass ）。 ​ 一般来说，你可以在任何时间做这些修改。理想情况下，大部分的约束应该在 Interface Builder 中设置，或者由视图控制器在控制器的初始化设置（比如，在 viewDidLoad 中）中编程创建。如果需要在运行时动态修改约束，一般最好是在应用的状态发生改变时去修改。比如，如果你在一个按钮被点击后，作为响应，修改一个约束，就在按钮的 action 方法中直接修改。 ​ 偶尔情况下可能出于性能原因，你需要对一组修改进行批处理。想要了解更多，查看4.5.2 批处理修改。 The Deferred Layout Pass​ Auto Layou 在约束发生修改之后，没有立刻更新受影响视图的 frame ，而是在不久的将来调度了一个 layout pass 。这个推迟的 layout pass会更新布局的约束集然后为视图层级中的所有视图计算 frame 。 ​ 我们可以调度我们自己的 Deferred Layout Pass ，通过调用 setNeedsLayout 方法或者 setNeedsUpdateConstraints 方法。 The Deferred Layout Pass 其实在整个视图层级中包括两个 passes： update pass 在必要时，更新约束。 layout pass 在必要时，重新定位视图的 frame 。 update pass ​ 系统穿过视图层级然后调用所有视图控制器的 updateViewConstraints 方法，和所有视图的 updateConstraints 方法。你可以重载这些方法，来优化对约束的修改（查看4.5.2 批处理修改）。 layout pass ​ 系统再次穿过视图层级，调用所有视图控制器的 viewWillLayoutSubviews 方法，和所有视图的 layoutSubviews 方法（OS X 中为 layout 方法）。默认情况下，layoutSubviews 方法使用由 Auto Layout 引擎计算的 rectangle 来更新每个子视图的 frame。你可以重载这些方法来修改布局（查看 4.5.1 自定义布局 ）。 批处理修改​ 在约束的改变放生后，立刻更新约束总是最容易、简洁的方式。推迟这些改变到一个稍后的方法中，让代码变得复杂、难以阅读。 ​ 但是，还是有些情况，你会因为性能原因想要批处理一些修改。只有在就地修改约束太过缓慢，或者当视图产生大量冗余的修改时，才应该这样做。 ​ 想要批处理修改，而不是直接更改，调用持有该约束的视图的 setNeedsUpdateConstraints 方法。然后，重载视图的 updateConstraints 方法来修改受到影响的约束。 NOTE 你的 updateConstraints 的实现必须尽可能的高效。不要注销你所有的约束，然后再激活你需要的那些。相反，你的 App 必须有某些方式来追踪你的约束，然后在每次 update pass 中验证它们。只改变那些需要被改变的项。在每次 update pass 之间，你得确保为 App 当前的状态，有适当的约束集。 ​ 在你的 updateConstraints 方法的实现的最后一步，总是调用父类的实现。 ​ 不要在 updateConstraints 方法中调用 setNeedsUpdateConstraints 方法。调用 setNeedsUpdateConstraints 方法来调度另外一个 update pass，创建一个反馈回路。 自定义布局​ 重载 viewWillLayoutSubviews 方法或者 layoutSubviews 方法来修改布局引擎返回的结果。 I M P O R T A N T 如果可能的话，用约束定义我们全部的布局。这样结果的布局更健壮，调试起来也更容易。你应该仅仅在当需要创建一个布局，而这个布局无法仅用约束来表示的时候，才重载 viewWillLayoutSubviews 或者 layoutSubviews 方法。 当重载这些方法时，布局处于一个不一致的状态。部分视图已经被布局，另一些还没。在修改视图层级时，要特别小心，或者你可以创建反馈回路。以下几条规则应该能帮助你避免反馈回路： 你必须在你方法中的某个地方调用父类的实现。 你可以安全地使子树中的视图布局失效；但是，你必须在调用父类的实现之前这么做。 不要让任何你子树之外的任何视图的布局失效。这有可能会创建一个反馈回路。 不要调用 setNeedsUpdateConstraints 。你刚刚完成一次 update pass。调用这个方法会产生反馈回路。 不要调用 setNeedsLayout 。调用这个方法会产生反馈回路。 修改约束时要谨慎。我们并不想让子树之外的任何视图的布局意外失效。 5 附录Visual Format Language​ 该附录展示了如何使用 Auto Layout Visual Format Language 来指定常见的约束，包括标准的间距和维度，垂直布局和不同优先级的约束。此外，这个附录包含了一个完整的语言的语法。 Visual 格式句法​ 以下是我们可以用 visual 格式指定的约束的例子。注意字符串文本与图片的在视觉上的对应。 标准间隔 1[button]-[textField] 宽度约束 1[button(&gt;=50)] 与父视图连接 1|-50-[purpleBox]-50-| 垂直布局 1V:[topField]-10-[bottomField] 齐平视图 1[maroonView][blueView] 优先级 1[button(100@20)] 等宽 1[button1(==button2)] 多重谓词 1[flexibleButton(&gt;=70,&lt;=100)] 一条完整线性布局 1|-[find]-[findNext]-[findField(&gt;=20)]-| ​ 这种表示法相对于完整的表达性，更倾向于良好的可视化。大部分在真正的用户界面上有用的约束都可以用 visual 格式句法表示，不过还是有一些不能表示的。一个不能被表达的有用的约束的例子，是固定的高宽比（比如，imageView.width = 2 imageView.height* ）。想要创建这样一个约束你必须使用 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 方法。 Visual 格式字符串语法​ Visual 格式字符串语法定义如下（文字用代码字体显示；e 表示空字符串）。 Symbol Replacement rule \\ (\\:)?、(\\\\)?、\\(\\\\)*、(\\\\)? \\ H\\ V \\ \\ [()?] e\\ --\\ - \\ \\ ((,)*) ()?()(@)? ==\\ &lt;=\\ &gt;= \\ (see note) \\ \\ Parsed as a C identifier. This must be a key mapping to an instance of NSView in the passed views dictionary. Parsed as a C identifier. This must be a key mapping to an instance of NSNumber in the passed metrics dictionary. As parsed by strtod_l, with the C locale. NOTE 对于 objectOfPredicate production 来说，只有当谓词的主语是视图的宽度或高度时，viewName才可以被接受。就是说，你可以使用 12&gt; [view1(==view2)] &gt; &gt; 来指定 view1 与 view2 等宽。 如果你句法出错，一个带有诊断信息的异常会被抛出。比如： 123456789101112131415Expected &apos;:&apos; after &apos;V&apos; to specify vertical arrangementV|[backgroundBox]| ^ A predicate on a view&apos;s thickness must end with &apos;)&apos; and the view must end with &apos;]&apos;|[whiteBox1][blackBox4(blackWidth][redBox]| ^ Unable to find view with name blackBox|[whiteBox2][blackBox] ^ Unknown relation. Must be ==, &gt;=, or &lt;=V:|[blackBox4(&gt;30)]| ^ 文档更改历史下面这个表格展示了 Auto Layout Guide 这片文档的变动。 日期 Notes 2016-03-21 添加了“修改约束”章节。 2015-12-10 在 Auto Layout 食谱章节中加入了高级食谱。合并其他小更新。 2015-09-16 增加了关于使用iOS size classes 的相关信息。增加了自动布局的一些例子。 2013-09-18 增加了关于Xcode5中 Auto Layout 的描述。 2012-09-19 加入到iOS库，加入了WWDC 视频链接。 2012-02-16 纠正一点代码错误。 2011-07-06 新文档描述了基于约束的系统，这个系统用于布局用户界面元素。","categories":[],"tags":[]}]}